<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MongoDB CSharp Driver</title>
    <link>/mongo-csharp-driver/1.11/</link>
    <description>Recent content on MongoDB CSharp Driver</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 18 Mar 2015 16:56:14 +0000</lastBuildDate>
    <atom:link href="/mongo-csharp-driver/1.11/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Getting Started</title>
      <link>/mongo-csharp-driver/1.11/getting_started/</link>
      <pubDate>Wed, 18 Mar 2015 16:56:14 +0000</pubDate>
      
      <guid>/mongo-csharp-driver/1.11/getting_started/</guid>
      <description>

&lt;h1 id=&#34;getting-started-with-the-c-driver&#34;&gt;Getting Started with the C# Driver&lt;/h1&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;This quick-start provides just enough information to get you started
using the C# driver. After you have gotten started you can refer to the
rest of the documentation for more information.&lt;/p&gt;

&lt;h2 id=&#34;downloading-the-c-driver&#34;&gt;Downloading the C# Driver&lt;/h2&gt;

&lt;p&gt;The simplest way to get started is by using the nuget package. The
&lt;a href=&#34;https://www.nuget.org/packages/mongocsharpdriver/&#34;&gt;package page&lt;/a&gt; will
provide details on using nuget.&lt;/p&gt;

&lt;p&gt;You can also download the C# driver here:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/mongodb/mongo-csharp-driver/releases&#34;&gt;https://github.com/mongodb/mongo-csharp-driver/releases&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you downloaded the &lt;code&gt;.zip&lt;/code&gt; file, simply unzip it and place the
contents anywhere you want.&lt;/p&gt;

&lt;p&gt;If you downloaded the &lt;code&gt;.msi&lt;/code&gt; file, double click on the &lt;code&gt;.msi&lt;/code&gt; file to
run the setup program, which will install the C# driver DLLs in the
&lt;code&gt;C:\Program Files (x86)\MongoDB\CSharp Driver 1.x&lt;/code&gt; directory (the exact
path may vary on your system).&lt;/p&gt;

&lt;h2 id=&#34;add-a-reference-to-the-c-driver-dlls&#34;&gt;Add a Reference to the C# Driver DLLs&lt;/h2&gt;

&lt;p&gt;Right click on the &lt;code&gt;References&lt;/code&gt; folder in Visual Studio&amp;rsquo;s Solution
Explorer and select &lt;code&gt;Add Reference...&lt;/code&gt;. Navigate to the folder where the
C# driver DLLs were installed and add a reference to the following
DLLs:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;MongoDB.Bson.dll&lt;/li&gt;
&lt;li&gt;MongoDB.Driver.dll&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As an alternative you could use the &lt;code&gt;NuGet&lt;/code&gt; package manager to add the
C# driver package to your solution.&lt;/p&gt;

&lt;h2 id=&#34;add-required-using-statements&#34;&gt;Add Required &lt;code&gt;using&lt;/code&gt; Statements&lt;/h2&gt;

&lt;p&gt;As a minimum you will need the following using statements:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;using MongoDB.Bson;
using MongoDB.Driver;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Additionally, you will frequently add one or more of these using
statements:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;using MongoDB.Driver.Builders;
using MongoDB.Driver.GridFS;
using MongoDB.Driver.Linq;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are additional namespaces that would only be required in special
cases.&lt;/p&gt;

&lt;h2 id=&#34;get-a-reference-to-the-client-object&#34;&gt;Get a Reference to the Client Object&lt;/h2&gt;

&lt;p&gt;The easiest way to get a reference to a client object is using a
connection string:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var connectionString = &amp;quot;mongodb://localhost&amp;quot;;
var client = new MongoClient(connectionString);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to store the client object in a global variable you can.
&lt;code&gt;MongoClient&lt;/code&gt; is thread-safe.&lt;/p&gt;

&lt;h2 id=&#34;get-a-reference-to-a-server-object&#34;&gt;Get a Reference to a Server Object&lt;/h2&gt;

&lt;p&gt;To get a reference to a server object from the client object, write
this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var server = client.GetServer();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;get-a-reference-to-a-database-object&#34;&gt;Get a Reference to a Database Object&lt;/h2&gt;

&lt;p&gt;To get a reference to a database object from the server object, write
this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var database = server.GetDatabase(&amp;quot;test&amp;quot;); // &amp;quot;test&amp;quot; is the name of the database
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you use more than one database, call &lt;code&gt;GetDatabase&lt;/code&gt; again for each
database you want to use.&lt;/p&gt;

&lt;h2 id=&#34;bsondocument-object-model-vs-your-own-domain-classes&#34;&gt;&lt;code&gt;BsonDocument&lt;/code&gt; Object Model vs. Your Own Domain Classes&lt;/h2&gt;

&lt;p&gt;There are two ways you can work with collections:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;using the &lt;code&gt;BsonDocument&lt;/code&gt; object model&lt;/li&gt;
&lt;li&gt;using your own domain classes&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You would use the &lt;code&gt;BsonDocument&lt;/code&gt; object model when the data you are
working with is so free form that it would be difficult or impossible to
define domain classes for it.&lt;/p&gt;

&lt;p&gt;Because it is so much easier to work with your own domain classes this
quick-start will assume that you are going to do that. The C# driver
can work with your domain classes provided that they:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Have a no-argument constructor&lt;/li&gt;
&lt;li&gt;Define public read/write fields or properties for the data you want
stored in the database&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These requirements are essentially the same as those imposed by .NET&amp;rsquo;s
XmlSerializer.&lt;/p&gt;

&lt;p&gt;In addition, if your domain class is going to be used as the root
document it must contain an &lt;em&gt;Id&lt;/em&gt; field or property (typically named &lt;code&gt;Id&lt;/code&gt;
although you can override that if necessary). Normally the &lt;em&gt;Id&lt;/em&gt; will be
of type &lt;code&gt;ObjectId&lt;/code&gt;, but there are no constraints on the type of this
member.&lt;/p&gt;

&lt;p&gt;Consider the following class definition:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class Entity
{
    public ObjectId Id { get; set; }

    public string Name { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;get-a-reference-to-a-collection-object&#34;&gt;Get a Reference to a Collection Object&lt;/h2&gt;

&lt;p&gt;You would get a reference to a collection containing &lt;code&gt;Entity&lt;/code&gt; documents
like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;// &amp;quot;entities&amp;quot; is the name of the collection
var collection = database.GetCollection&amp;lt;Entity&amp;gt;(&amp;quot;entities&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;insert-a-document&#34;&gt;Insert a Document&lt;/h2&gt;

&lt;p&gt;To insert an &lt;code&gt;Entity&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var entity = new Entity { Name = &amp;quot;Tom&amp;quot; };
collection.Insert(entity);
var id = entity.Id; // Insert will set the Id if necessary (as it was in this example)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;find-an-existing-document&#34;&gt;Find an Existing Document&lt;/h2&gt;

&lt;p&gt;In this example we will read back an &lt;code&gt;Entity&lt;/code&gt; assuming we know the &lt;em&gt;Id&lt;/em&gt;
value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query = Query&amp;lt;Entity&amp;gt;.EQ(e =&amp;gt; e.Id, id);
var entity = collection.FindOne(query);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Query&amp;lt;Entity&amp;gt;.EQ&lt;/code&gt; uses the &lt;code&gt;Query&amp;lt;T&amp;gt;&lt;/code&gt; builder class to build the query.
The lambda expression &lt;code&gt;e =&amp;gt; e.Id&lt;/code&gt; is translated to &lt;em&gt;_id&lt;/em&gt;. This is the
name of the field as stored in the database.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Normally the name of the field in the database is exactly the same as
the name of the field or property in your domain class, but &lt;em&gt;Id&lt;/em&gt; is an
exception and is mapped to &lt;code&gt;_id&lt;/code&gt; in the database.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Other query operators include: &lt;code&gt;GT&lt;/code&gt;, &lt;code&gt;GTE&lt;/code&gt;, &lt;code&gt;In&lt;/code&gt;, &lt;code&gt;LT&lt;/code&gt;, &lt;code&gt;LTE&lt;/code&gt;, &lt;code&gt;Near&lt;/code&gt;,
&lt;code&gt;NE&lt;/code&gt;, &lt;code&gt;And&lt;/code&gt;, &lt;code&gt;Or&lt;/code&gt; (and a few other more specialized ones).&lt;/p&gt;

&lt;h2 id=&#34;save-a-document&#34;&gt;Save a Document&lt;/h2&gt;

&lt;p&gt;You can save changes to an existing document like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;entity.Name = &amp;quot;Dick&amp;quot;;
collection.Save(entity);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;update-an-existing-document&#34;&gt;Update an Existing Document&lt;/h2&gt;

&lt;p&gt;An alternative to &lt;code&gt;Save&lt;/code&gt; is &lt;code&gt;Update&lt;/code&gt;. The difference is that &lt;code&gt;Save&lt;/code&gt;
sends the entire document back to the server, but &lt;code&gt;Update&lt;/code&gt; sends just
the changes. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query = Query&amp;lt;Entity&amp;gt;.EQ(e =&amp;gt; e.Id, id);
var update = Update&amp;lt;Entity&amp;gt;.Set(e =&amp;gt; e.Name, &amp;quot;Harry&amp;quot;); // update modifiers
collection.Update(query, update);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example uses the &lt;code&gt;Update&amp;lt;T&amp;gt;&lt;/code&gt; builder to easily build the update
modifiers.&lt;/p&gt;

&lt;h2 id=&#34;remove-an-existing-document&#34;&gt;Remove an Existing Document&lt;/h2&gt;

&lt;p&gt;To remove an existing document from a collection you write:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query = Query&amp;lt;Entity&amp;gt;.EQ(e =&amp;gt; e.Id, id);
collection.Remove(query);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;you-do-not-need-to-call-connect-or-disconnect&#34;&gt;You Do NOT Need to Call Connect or Disconnect&lt;/h2&gt;

&lt;p&gt;The C# driver has a connection pool to use connections to the server
efficiently. There is no need to call &lt;code&gt;Connect&lt;/code&gt; or &lt;code&gt;Disconnect&lt;/code&gt;; just
let the driver take care of the connections (calling &lt;code&gt;Connect&lt;/code&gt; is
harmless, but calling &lt;code&gt;Disconnect&lt;/code&gt; is bad because it closes all the
connections in the connection pool).&lt;/p&gt;

&lt;h2 id=&#34;full-sample-program&#34;&gt;Full Sample Program&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using MongoDB.Bson;
using MongoDB.Driver;
using MongoDB.Driver.Builders;

namespace ConsoleApplication1
{
    public class Entity
    {
        public ObjectId Id { get; set; }
        public string Name { get; set; }
    }

    class Program
    {
        static void Main(string[] args)
        {
            var connectionString = &amp;quot;mongodb://localhost&amp;quot;;
            var client = new MongoClient(connectionString);
            var server = client.GetServer();
            var database = server.GetDatabase(&amp;quot;test&amp;quot;);
            var collection = database.GetCollection&amp;lt;Entity&amp;gt;(&amp;quot;entities&amp;quot;);

            var entity = new Entity { Name = &amp;quot;Tom&amp;quot; };
            collection.Insert(entity);
            var id = entity.Id;

            var query = Query&amp;lt;Entity&amp;gt;.EQ(e =&amp;gt; e.Id, id);
            entity = collection.FindOne(query);

            entity.Name = &amp;quot;Dick&amp;quot;;
            collection.Save(entity);

            var update = Update&amp;lt;Entity&amp;gt;.Set(e =&amp;gt; e.Name, &amp;quot;Harry&amp;quot;);
            collection.Update(query, update);

            collection.Remove(query);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Driver Tutorial</title>
      <link>/mongo-csharp-driver/1.11/driver/</link>
      <pubDate>Wed, 18 Mar 2015 16:56:14 +0000</pubDate>
      
      <guid>/mongo-csharp-driver/1.11/driver/</guid>
      <description>

&lt;h1 id=&#34;driver-tutorial&#34;&gt;Driver Tutorial&lt;/h1&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;This tutorial introduces the officially supported C# Driver for
MongoDB. The C# Driver consists of two libraries: the BSON Library and
the C# Driver. The BSON Library can be used independently of the C#
Driver if desired. The C# Driver requires the BSON Library.&lt;/p&gt;

&lt;p&gt;You may also be interested in the C# Driver Serialization
Tutorial &amp;lt;/tutorial/serialize-documents-with-the-csharp-driver&amp;gt;. It is
a separate tutorial because it covers quite a lot of material.&lt;/p&gt;

&lt;h2 id=&#34;downloading&#34;&gt;Downloading&lt;/h2&gt;

&lt;p&gt;The C# Driver is available in source and binary form. While the BSON
Library can be used independently of the C# Driver they are both stored
in the same repository.&lt;/p&gt;

&lt;p&gt;The simplest way to get started is by using the nuget package. The
&lt;a href=&#34;https://www.nuget.org/packages/mongocsharpdriver/&#34;&gt;package page&lt;/a&gt; will
provide details on using nuget.&lt;/p&gt;

&lt;p&gt;The source may be downloaded from
&lt;a href=&#34;http://github.com/mongodb/mongo-csharp-driver&#34;&gt;github.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We use &lt;code&gt;msysgit&lt;/code&gt; as our Windows git client. It can be downloaded from:
&lt;a href=&#34;http://msysgit.github.com&#34;&gt;http://msysgit.github.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To clone the repository run the following commands from a git bash
shell:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode sh&#34;&gt;cd &amp;lt;parentdirectory&amp;gt;
git config --global core.autocrlf true
git clone git://github.com/mongodb/mongo-csharp-driver.git
cd mongo-csharp-driver
git config core.autocrlf true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You must set the global setting for &lt;code&gt;core.autocrlf&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; before
cloning the repository. After you clone the repository, we recommend you
set the local setting for &lt;code&gt;core.autocrlf&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; (as shown above) so
that future changes to the global setting for &lt;code&gt;core.autocrlf&lt;/code&gt; do not
affect this repository. If you then want to change your global setting
for &lt;code&gt;core.autocrlf&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; run:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode sh&#34;&gt;git config --global core.autocrlf false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The typical symptom of problems with the setting for &lt;code&gt;core.autocrlf&lt;/code&gt; is
git reporting that an entire file has been modified (because of
differences in the line endings). It is rather tedious to change the
setting of &lt;code&gt;core.autocrlf&lt;/code&gt; for a repository after it has been created,
so it is important to get it right from the start.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You can download a zip file of the source files (without cloning the
repository) by clicking on the Downloads button at:
&lt;a href=&#34;http://github.com/mongodb/mongo-csharp-driver&#34;&gt;http://github.com/mongodb/mongo-csharp-driver&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;You can download binaries (in both &lt;code&gt;.msi&lt;/code&gt; and &lt;code&gt;.zip&lt;/code&gt; formats) from:
&lt;a href=&#34;https://github.com/mongodb/mongo-csharp-driver/releases&#34;&gt;https://github.com/mongodb/mongo-csharp-driver/releases&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;building&#34;&gt;Building&lt;/h2&gt;

&lt;p&gt;We are currently building the C# Driver with Visual Studio 2012. The
name of the solution file is CSharpDriver.sln.&lt;/p&gt;

&lt;h2 id=&#34;running-unit-tests&#34;&gt;Running Unit Tests&lt;/h2&gt;

&lt;p&gt;The unit tests depend on NUnit 2.6, which is included in the Tools
folder of the repository. You can build the C# Driver without
installing NUnit, but you must have a test runner capable of running
NUnit tests in order to run the tests.&lt;/p&gt;

&lt;p&gt;There are three projects containing unit tests:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;BsonUnitTests&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DriverUnitTests&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DriverUnitTestsVB&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The &lt;code&gt;BsonUnitTests&lt;/code&gt; do not connect to a MongoDB server. The
&lt;code&gt;DriverUnitTests&lt;/code&gt; and &lt;code&gt;DriverUnitTestsVB&lt;/code&gt; connect to an instance of
MongoDB running on the default port (27017) on localhost.&lt;/p&gt;

&lt;p&gt;If you are running Visual Studio 2012, you can use the NUnit Test
Adapter extension to run the unit tests. This is by far the easiest
solution.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The NUnit Test Adapter for Visual Studio 2012 is an extension that
must be installed through the Visual Studio Extension Manager.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;An alternative is to use the NUnit Test Runner. An easy way to use the
NUnit Test Runner is to set one of the unit test projects as the startup
project and configure the project settings as follows (using
&lt;code&gt;BsonUnitTests&lt;/code&gt; as an example):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;On the &lt;strong&gt;Debug&lt;/strong&gt; tab:

&lt;ul&gt;
&lt;li&gt;Set &lt;code&gt;Start Action&lt;/code&gt; to: &lt;code&gt;Start External Program&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Set &lt;code&gt;external program&lt;/code&gt; to: .\\Tools\\NUnit\\nunit.exe&lt;/li&gt;
&lt;li&gt;Set &lt;code&gt;command line arguments&lt;/code&gt; to:
&lt;code&gt;BsonUnitTests.csproj /config:Debug /run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Set &lt;code&gt;working directory&lt;/code&gt; to: the directory where
BsonUnitTest.csproj is located.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Repeat the above steps for the &lt;code&gt;Release&lt;/code&gt; configuration (using
&lt;code&gt;/config:Release&lt;/code&gt; instead) if you also want to run unit tests for
&lt;code&gt;Release&lt;/code&gt; builds.&lt;/p&gt;

&lt;p&gt;To run the &lt;code&gt;DriverUnitTests&lt;/code&gt; and &lt;code&gt;DriverUnitTestsVB&lt;/code&gt; perform the same
steps (modified as necessary).&lt;/p&gt;

&lt;h2 id=&#34;installing&#34;&gt;Installing&lt;/h2&gt;

&lt;p&gt;If you want to install the C# Driver on your machine, you can use the
setup program (see above for download instructions). The setup program
is very simple and just copies the DLLs to your specified installation
directory.&lt;/p&gt;

&lt;p&gt;If you downloaded the binaries zip file simply extract the files and
place them wherever you want them to be.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If you download the &lt;code&gt;.zip&lt;/code&gt; file, Windows might require you to
&amp;ldquo;Unblock&amp;rdquo; the help file. If Windows asks &amp;ldquo;Do you want to open this
file?&amp;rdquo; when you double click on the CSharpDriverDocs.chm file, clear
the check box next to &amp;ldquo;Always ask before opening this file&amp;rdquo; before
pressing the Open button. Alternatively, you can right click on the
CSharpDriverDocs.chm file and select &lt;code&gt;Properties&lt;/code&gt;, and then press the
&lt;code&gt;Unblock&lt;/code&gt; button at the bottom of the &lt;code&gt;General&lt;/code&gt; tab. If the &lt;code&gt;Unblock&lt;/code&gt;
button is not present then the help file does not need to be
unblocked.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;references-and-namespaces&#34;&gt;References and Namespaces&lt;/h2&gt;

&lt;p&gt;To use the C# Driver you must add references to the following DLLs:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;MongoDB.Bson.dll&lt;/li&gt;
&lt;li&gt;MongoDB.Driver.dll&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If you used nuget to pull down the assemblies, these references likely
already exist.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As a minimum add the following using statements to your source files:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;using MongoDB.Bson;
using MongoDB.Driver;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Additionally you will frequently add some of the following using
statements:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;using MongoDB.Driver.Builders;
using MongoDB.Driver.GridFS;
using MongoDB.Driver.Linq;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In some cases you might add some of the following using statements if
you are using some of the optional parts of the C# Driver:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;using MongoDB.Bson.IO;
using MongoDB.Bson.Serialization;
using MongoDB.Bson.Serialization.Attributes;
using MongoDB.Bson.Serialization.Conventions;
using MongoDB.Bson.Serialization.IdGenerators;
using MongoDB.Bson.Serialization.Options;
using MongoDB.Bson.Serialization.Serializers;
using MongoDB.Driver.Wrappers;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-bson-library&#34;&gt;The BSON Library&lt;/h2&gt;

&lt;p&gt;The C# Driver is built on top of the BSON Library, which handles all
the details of the BSON specification, including: I/O, serialization,
and an in-memory object model of BSON documents.&lt;/p&gt;

&lt;p&gt;The important classes of the BSON object model are: &lt;code&gt;BsonType&lt;/code&gt;,
&lt;code&gt;BsonValue&lt;/code&gt;, &lt;code&gt;BsonElement&lt;/code&gt;, &lt;code&gt;BsonDocument&lt;/code&gt; and &lt;code&gt;BsonArray&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;bsontype&#34;&gt;&lt;code&gt;BsonType&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;This enumeration is used to specify the type of a BSON value. It is
defined as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public enum BsonType {
    Double = 0x01,
    String = 0x02,
    Document = 0x03,
    Array = 0x04,
    Binary = 0x05,
    Undefined = 0x06,
    ObjectId = 0x07,
    Boolean = 0x08,
    DateTime = 0x09,
    Null = 0x0a,
    RegularExpression = 0x0b,
    JavaScript = 0x0d,
    Symbol = 0x0e,
    JavaScriptWithScope = 0x0f,
    Int32 = 0x10,
    Timestamp = 0x11,
    Int64 = 0x12,
    MinKey = 0xff,
    MaxKey = 0x7f
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bsonvalue-and-subclasses&#34;&gt;&lt;code&gt;BsonValue&lt;/code&gt; and Subclasses&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;BsonValue&lt;/code&gt; is an abstract class that represents a typed BSON value.
There is a concrete subclass of &lt;code&gt;BsonValue&lt;/code&gt; for each of the values
defined by the &lt;code&gt;BsonType&lt;/code&gt; enum. There are several ways to obtain an
instance of &lt;code&gt;BsonValue&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Use a public constructor (if available) of a subclass of &lt;code&gt;BsonValue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Use a static &lt;code&gt;Create&lt;/code&gt; method of &lt;code&gt;BsonValue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Use a static &lt;code&gt;Create&lt;/code&gt; method of a subclass of &lt;code&gt;BsonValue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Use a static property of a subclass of &lt;code&gt;BsonValue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Use an implicit conversion to &lt;code&gt;BsonValue&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The advantage of using the static &lt;code&gt;Create&lt;/code&gt; methods is that they can
return a pre-created instance for frequently used values. They can also
return &lt;code&gt;null&lt;/code&gt; (which a constructor cannot) which is useful for handling
optional elements when creating &lt;code&gt;BsonDocuments&lt;/code&gt; using functional
construction. The static properties refer to pre-created instances of
frequently used values. Implicit conversions allow you to use primitive
.NET values wherever a &lt;code&gt;BsonValue&lt;/code&gt; is expected, and the .NET value will
automatically be converted to a &lt;code&gt;BsonValue&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;bsontype-property&#34;&gt;&lt;code&gt;BsonType&lt;/code&gt; Property&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;BsonValue&lt;/code&gt; has a property called &lt;code&gt;BsonType&lt;/code&gt; that you can use to query
the actual type of a &lt;code&gt;BsonValue&lt;/code&gt;. The following example shows several
ways to determine the type of a &lt;code&gt;BsonValue&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonValue value;
if (value.BsonType == BsonType.Int32) {
    // we know value is an instance of BsonInt32
}
if (value is BsonInt32) {
    // another way to tell that value is a BsonInt32
}
if (value.IsInt32) {
    // the easiest way to tell that value is a BsonInt32
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;as-type-properties&#34;&gt;&lt;code&gt;As[Type]&lt;/code&gt; Properties&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;BsonValue&lt;/code&gt; has a number of properties that cast a &lt;code&gt;BsonValue&lt;/code&gt; to one of
its subclasses or a primitive .NET type. It is important to note that
these all are casts, not conversions. They will throw an
&lt;code&gt;InvalidCastException&lt;/code&gt; if the &lt;code&gt;BsonValue&lt;/code&gt; is not of the corresponding
type. See also the To[Type] methods
&amp;lt;totype-conversion-methods&amp;gt; which do conversions, and the
Is[Type] properties &amp;lt;istype-properties&amp;gt; which you can use to query the
type of a &lt;code&gt;BsonValue&lt;/code&gt; before attempting to use one of the &lt;code&gt;As[Type]&lt;/code&gt;
properties.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonDocument document;
string name = document[&amp;quot;name&amp;quot;].AsString;
int age = document[&amp;quot;age&amp;quot;].AsInt32;
BsonDocument address = document[&amp;quot;address&amp;quot;].AsBsonDocument;
string zip = address[&amp;quot;zip&amp;quot;].AsString;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;is-type-properties&#34;&gt;&lt;code&gt;Is[Type]&lt;/code&gt; Properties&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;BsonValue&lt;/code&gt; has the following boolean properties, you can use to test
what kind of &lt;code&gt;BsonValue&lt;/code&gt; it is. These can be used as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonDocument document;
int age = -1;
if (document.Contains[&amp;quot;age&amp;quot;] &amp;amp;&amp;amp; document[&amp;quot;age&amp;quot;].IsInt32) {
    age = document[&amp;quot;age&amp;quot;].AsInt32;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;to-type-conversion-methods&#34;&gt;&lt;code&gt;To[Type]&lt;/code&gt; Conversion Methods&lt;/h3&gt;

&lt;p&gt;Unlike the &lt;code&gt;As[Type]&lt;/code&gt; methods, the &lt;code&gt;To[Type]&lt;/code&gt; methods perform some
limited conversion between convertible types, like &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;ToBoolean&lt;/code&gt; method never fails. It uses JavaScript&amp;rsquo;s definition of
truthiness: &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;0.0&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;BsonNull&lt;/code&gt;, &lt;code&gt;BsonUndefined&lt;/code&gt; and
&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; are &lt;code&gt;false&lt;/code&gt;, and everything else is &lt;code&gt;true&lt;/code&gt; (include the string
&lt;code&gt;&amp;quot;false&amp;quot;&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;ToBoolean&lt;/code&gt; method is particularly useful when the documents you are
processing might have inconsistent ways of recording &lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;
values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;if (employee[&amp;quot;ismanager&amp;quot;].ToBoolean()) {
    // we know the employee is a manager
    // works with many ways of recording boolean values
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;ToDouble&lt;/code&gt;, &lt;code&gt;ToInt32&lt;/code&gt;, and &lt;code&gt;ToInt64&lt;/code&gt; methods never fail when
converting between numeric types, though the value might be truncated if
it doesn&amp;rsquo;t fit in the target type. A string can be converted to a
numeric type, but an exception will be thrown if the string cannot be
parsed as a value of the target type.&lt;/p&gt;

&lt;h3 id=&#34;static-create-methods&#34;&gt;Static Create Methods&lt;/h3&gt;

&lt;p&gt;Because &lt;code&gt;BsonValue&lt;/code&gt; is an abstract class you cannot create instances of
&lt;code&gt;BsonValue&lt;/code&gt; (only instances of concrete subclasses). &lt;code&gt;BsonValue&lt;/code&gt; has a
static &lt;code&gt;Create&lt;/code&gt; method that takes an argument of type &lt;code&gt;object&lt;/code&gt; and
determines at runtime the actual type of &lt;code&gt;BsonValue&lt;/code&gt; to create.
Subclasses of &lt;code&gt;BsonValue&lt;/code&gt; also have static &lt;code&gt;Create&lt;/code&gt; methods tailored to
their own needs.&lt;/p&gt;

&lt;h4 id=&#34;implicit-conversions&#34;&gt;Implicit Conversions&lt;/h4&gt;

&lt;p&gt;Implicit conversions are defined from the following .NET types to
&lt;code&gt;BsonValue&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;byte[]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;double&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Guid&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;long&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ObjectId&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These eliminate the need for almost all calls to &lt;code&gt;BsonValue&lt;/code&gt;
constructors or &lt;code&gt;Create&lt;/code&gt; methods. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonValue b = true; // b is an instance of BsonBoolean
BsonValue d = 3.14159; // d is an instance of BsonDouble
BsonValue i = 1; // i is an instance of BsonInt32
BsonValue s = &amp;quot;Hello&amp;quot;; // s is an instance of BsonString
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bsonmaxkey-bsonminkey-bsonnull-and-bsonundefined&#34;&gt;&lt;code&gt;BsonMaxKey&lt;/code&gt;, &lt;code&gt;BsonMinKey&lt;/code&gt;, &lt;code&gt;BsonNull&lt;/code&gt; and &lt;code&gt;BsonUndefined&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;These classes are singletons, so only a single instance of each class
exists. You refer to these instances using the static &lt;code&gt;Value&lt;/code&gt; property
of each class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;document[&amp;quot;status&amp;quot;] = BsonNull.Value;
document[&amp;quot;priority&amp;quot;] = BsonMaxKey.Value;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that C# &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;BsonNull.Value&lt;/code&gt; are two different things. The
latter is an actual C# object that represents a BSON &lt;code&gt;null&lt;/code&gt; value (it&amp;rsquo;s
a subtle difference, but plays an important role in functional
construction).&lt;/p&gt;

&lt;h3 id=&#34;objectid-and-bsonobjectid&#34;&gt;&lt;code&gt;ObjectId&lt;/code&gt; and &lt;code&gt;BsonObjectId&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ObjectId&lt;/code&gt; is a struct that holds the raw value of a BSON &lt;code&gt;ObjectId&lt;/code&gt;.
&lt;code&gt;BsonObjectId&lt;/code&gt; is a subclass of &lt;code&gt;BsonValue&lt;/code&gt; whose Value property is of
type &lt;code&gt;ObjectId&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here are some common ways of creating &lt;code&gt;ObjectId&lt;/code&gt; values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var id1 = new ObjectId(); // same as ObjectId.Empty
var id2 = ObjectId.Empty; // all zeroes
var id3 = ObjectId.GenerateNewId(); // generates new unique Id
var id4 = ObjectId.Parse(&amp;quot;4dad901291c2949e7a5b6aa8&amp;quot;); // parses a 24 hex digit string
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The first example behaves differently in C# than in JavaScript. In
C# it creates an &lt;code&gt;ObjectId&lt;/code&gt; of all zeroes, but in JavaScript it
generates a new unique &lt;code&gt;Id&lt;/code&gt;. This difference can&amp;rsquo;t be avoided because
in C# the default constructor of a value type always initializes the
value to all zeros.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;bsonelement&#34;&gt;&lt;code&gt;BsonElement&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;A &lt;code&gt;BsonElement&lt;/code&gt; is a name/value pair, where the value is a &lt;code&gt;BsonValue&lt;/code&gt;.
It is used as the building block of &lt;code&gt;BsonDocument&lt;/code&gt;, which consists of
zero or more elements. You will rarely create &lt;code&gt;BsonElements&lt;/code&gt; directly,
as they are usually created indirectly as needed. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;document.Add(new BsonElement(&amp;quot;age&amp;quot;, 21)); // OK, but next line is shorter
document.Add(&amp;quot;age&amp;quot;, 21); // creates BsonElement automatically
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bsondocument&#34;&gt;&lt;code&gt;BsonDocument&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;A &lt;code&gt;BsonDocument&lt;/code&gt; is a collection of name/value pairs (represented by
&lt;code&gt;BsonElements&lt;/code&gt;). It is an in-memory object model of a BSON document.
There are three ways to create and populate a &lt;code&gt;BsonDocument&lt;/code&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create a new document and call &lt;code&gt;Add&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt; methods.&lt;/li&gt;
&lt;li&gt;Create a new document and use the fluent interface &lt;code&gt;Add&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt;
methods.&lt;/li&gt;
&lt;li&gt;Create a new document and use C#&amp;rsquo;s collection initializer syntax
(recommended).&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;bsondocument-constructor&#34;&gt;&lt;code&gt;BsonDocument&lt;/code&gt; Constructor&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;BsonDocument&lt;/code&gt; has the following constructors:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BsonDocument()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonDocument(string name, BsonValue value)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonDocument(BsonElement element)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonDocument(Dictionary&amp;lt;string, object&amp;gt; dictionary)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonDocument(Dictionary&amp;lt;string, object&amp;gt; dictionary, IEnumerable&amp;lt;string&amp;gt; keys)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonDocument(IDictionary dictionary)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonDocument(IDictionary dictionary, IEnumerable&amp;lt;string&amp;gt; keys)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonDocument(IDictionary&amp;lt;string, object&amp;gt; dictionary)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonDocument(IDictionary&amp;lt;string, object&amp;gt; dictionary, IEnumerable&amp;lt;string&amp;gt; keys)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonDocument(IEnumerable&amp;lt;BsonElement&amp;gt; elements)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonDocument(params BsonElement[] elements)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonDocument(bool allowDuplicateNames)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first two are the ones you are most likely to use. The first creates
an empty document, and the second creates a document with one element
(in both cases you can of course add more elements).&lt;/p&gt;

&lt;p&gt;All the constructors (except the one with &lt;code&gt;allowDuplicateNames&lt;/code&gt;) simply
call the &lt;code&gt;Add&lt;/code&gt; method that takes the same parameters, so refer to the
corresponding &lt;code&gt;Add&lt;/code&gt; method for details about how the new document is
initially populated.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;BsonDocument&lt;/code&gt; normally does not allow duplicate names, but if you
must allow duplicate names call the constructor with the
&lt;code&gt;allowDuplicateNames&lt;/code&gt; parameter and pass in &lt;code&gt;true&lt;/code&gt;. It is &lt;em&gt;not&lt;/em&gt;
recommended that you allow duplicate names, and this option exists only
to allow handling existing BSON documents that might have duplicate
names. MongoDB makes no particular guarantees about whether it supports
documents with duplicate names, so be cautious about sending any such
documents you construct to the server.&lt;/p&gt;

&lt;h3 id=&#34;create-a-new-document-and-call-add-and-set-methods&#34;&gt;Create a New Document and Call &lt;code&gt;Add&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt; Methods&lt;/h3&gt;

&lt;p&gt;This is a traditional step by step method to create and populate a
document using multiple C# statements. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonDocument book = new BsonDocument();
book.Add(&amp;quot;author&amp;quot;, &amp;quot;Ernest Hemingway&amp;quot;);
book.Add(&amp;quot;title&amp;quot;, &amp;quot;For Whom the Bell Tolls&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;create-a-new-document-and-use-the-fluent-interface-add-and-set-methods&#34;&gt;Create a New Document and Use the Fluent Interface &lt;code&gt;Add&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt; Methods&lt;/h3&gt;

&lt;p&gt;This is similar to the previous approach but the fluent interface allows
you to chain the various calls to &lt;code&gt;Add&lt;/code&gt; so that they are all a single
C# statement. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonDocument book = new BsonDocument()
    .Add(&amp;quot;author&amp;quot;, &amp;quot;Ernest Hemingway&amp;quot;)
    .Add(&amp;quot;title&amp;quot;, &amp;quot;For Whom the Bell Tolls&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;create-a-new-document-and-use-c-s-collection-initializer-syntax-recommended&#34;&gt;Create a New Document and Use C#&amp;rsquo;s Collection Initializer Syntax (Recommended)&lt;/h3&gt;

&lt;p&gt;This is the recommended way to create and initialize a &lt;code&gt;BsonDocument&lt;/code&gt; in
one statement. It uses C#&amp;rsquo;s collection initializer syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonDocument book = new BsonDocument {
    { &amp;quot;author&amp;quot;, &amp;quot;Ernest Hemingway&amp;quot; },
    { &amp;quot;title&amp;quot;, &amp;quot;For Whom the Bell Tolls&amp;quot; }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The compiler translates this into calls to the matching &lt;code&gt;Add&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonDocument book = new BsonDocument();
book.Add(&amp;quot;author&amp;quot;, &amp;quot;Ernest Hemingway&amp;quot;);
book.Add(&amp;quot;title&amp;quot;, &amp;quot;For Whom the Bell Tolls&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A common mistake is to forget the inner set of braces. This will result
in a compilation error. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonDocument bad = new BsonDocument {
    &amp;quot;author&amp;quot;, &amp;quot;Ernest Hemingway&amp;quot;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is translated by the compiler to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonDocument bad = new BsonDocument();
bad.Add(&amp;quot;author&amp;quot;);
bad.Add(&amp;quot;Ernest Hemingway&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which results in a compilation error because there is no &lt;code&gt;Add&lt;/code&gt; method
that takes a single string argument.&lt;/p&gt;

&lt;h3 id=&#34;creating-nested-bson-documents&#34;&gt;Creating Nested BSON Documents&lt;/h3&gt;

&lt;p&gt;Nested BSON documents are created by setting the value of an element to
a BSON document. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonDocument nested = new BsonDocument {
    { &amp;quot;name&amp;quot;, &amp;quot;John Doe&amp;quot; },
    { &amp;quot;address&amp;quot;, new BsonDocument {
        { &amp;quot;street&amp;quot;, &amp;quot;123 Main St.&amp;quot; },
        { &amp;quot;city&amp;quot;, &amp;quot;Centerville&amp;quot; },
        { &amp;quot;state&amp;quot;, &amp;quot;PA&amp;quot; },
        { &amp;quot;zip&amp;quot;, 12345}
    }}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates a top level document with two elements (&lt;code&gt;name&lt;/code&gt; and
&lt;code&gt;address&lt;/code&gt;). The value of &lt;code&gt;address&lt;/code&gt; is a nested BSON document.&lt;/p&gt;

&lt;h3 id=&#34;add-methods&#34;&gt;&lt;code&gt;Add&lt;/code&gt; Methods&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;BsonDocument&lt;/code&gt; has the following overloaded &lt;code&gt;Add&lt;/code&gt; methods:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Add(BsonElement element)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Add(Dictionary&amp;lt;string, object&amp;gt; dictionary)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Add(Dictionary&amp;lt;string, object&amp;gt; dictionary, IEnumerable&amp;lt;string&amp;gt; keys)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Add(IDictionary dictionary)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Add(IDictionary dictionary, IEnumerable&amp;lt;string&amp;gt; keys)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Add(IDictionary&amp;lt;string, object&amp;gt; dictionary)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Add(IDictionary&amp;lt;string, object&amp;gt; dictionary, IEnumerable&amp;lt;string&amp;gt; keys)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Add(IEnumerable&amp;lt;BsonElement&amp;gt; elements)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Add(string name, BsonValue value)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Add(string name, BsonValue value, bool condition)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It is important to note that sometimes the &lt;code&gt;Add&lt;/code&gt; methods &lt;em&gt;do NOT&lt;/em&gt; add a
new element. If the value supplied is &lt;code&gt;null&lt;/code&gt; (or the condition supplied
in the last overload is &lt;code&gt;false&lt;/code&gt;) then the element isn&amp;rsquo;t added. This
makes it really easy to handle optional elements without having to write
any if statements or conditional expressions.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonDocument document = new BsonDocument {
    { &amp;quot;name&amp;quot;, name },
    { &amp;quot;city&amp;quot;, city }, // not added if city is null
    { &amp;quot;dob&amp;quot;, dob, dobAvailable } // not added if dobAvailable is false
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is more compact and readable than:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonDocument document = new BsonDocument();
document.Add(&amp;quot;name&amp;quot;, name);
if (city != null) {
    document.Add(&amp;quot;city&amp;quot;, city);
}
if (dobAvailable) {
    document.Add(&amp;quot;dob&amp;quot;, dob);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to add a &lt;code&gt;BsonNull&lt;/code&gt; if a value is missing you have to say
so. A convenient way is to use C#&amp;rsquo;s &lt;code&gt;null&lt;/code&gt; coalescing operator as
follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonDocument = new BsonDocument {
    { &amp;quot;city&amp;quot;, city ?? BsonConstants.Null }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;IDictionary&lt;/code&gt; overloads initialize a &lt;code&gt;BsonDocument&lt;/code&gt; from a
dictionary. Each key in the dictionary becomes the name of a new
element, and each value is mapped to a matching &lt;code&gt;BsonValue&lt;/code&gt; and becomes
the value of the new element. The overload with the keys parameter lets
you select which dictionary entries to load (you might also use the keys
parameter to control the order in which the elements are loaded from the
dictionary).&lt;/p&gt;

&lt;h3 id=&#34;accessing-bsondocument-elements&#34;&gt;Accessing &lt;code&gt;BsonDocument&lt;/code&gt; Elements&lt;/h3&gt;

&lt;p&gt;The recommended way to access &lt;code&gt;BsonDocument&lt;/code&gt; elements is to use one of
the following indexers:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BsonValue this[int index]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonValue this[string name]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonValue this[string name, BsonValue defaultValue]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that the return value of the indexers is &lt;code&gt;BsonValue&lt;/code&gt;, not
&lt;code&gt;BsonElement&lt;/code&gt;. This actually makes &lt;code&gt;BsonDocuments&lt;/code&gt; much easier to work
with (if you ever need to get the actual &lt;code&gt;BsonElements&lt;/code&gt; use
&lt;code&gt;GetElement&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve already seen samples of accessing &lt;code&gt;BsonDocument&lt;/code&gt; elements. Here
are some more:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonDocument book;
string author = book[&amp;quot;author&amp;quot;].AsString;
DateTime publicationDate = book[&amp;quot;publicationDate&amp;quot;].AsDateTime;
int pages = book[&amp;quot;pages&amp;quot;, -1].AsInt32; // default value is -1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;bsonarray&#34;&gt;BsonArray&lt;/h2&gt;

&lt;p&gt;This class is used to represent BSON arrays. While arrays happen to be
represented externally as BSON documents (with a special naming
convention for the elements), the &lt;code&gt;BsonArray&lt;/code&gt; class is unrelated to the
&lt;code&gt;BsonDocument&lt;/code&gt; class because they are used very differently.&lt;/p&gt;

&lt;h3 id=&#34;constructors&#34;&gt;Constructors&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;BsonArray&lt;/code&gt; has the following constructors:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BsonArray()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonArray(IEnumerable&amp;lt;bool&amp;gt; values)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonArray(IEnumerable&amp;lt;BsonValue&amp;gt; values)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonArray(IEnumerable&amp;lt;DateTime&amp;gt; values)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonArray(IEnumerable&amp;lt;double&amp;gt; values)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonArray(IEnumerable&amp;lt;int&amp;gt; values)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonArray(IEnumerable&amp;lt;long&amp;gt; values)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonArray(IEnumerable&amp;lt;ObjectId&amp;gt; values)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonArray(IEnumerable&amp;lt;string&amp;gt; values)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonArray(IEnumerable values)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All the constructors with a parameter call the matching &lt;code&gt;Add&lt;/code&gt; method.
The multiple overloads are needed because C# does not provide automatic
conversions from &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;IEnumerable&amp;lt;object&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;add-and-addrange-methods&#34;&gt;&lt;code&gt;Add&lt;/code&gt; and &lt;code&gt;AddRange&lt;/code&gt; Methods&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;BsonArray&lt;/code&gt; has the following &lt;code&gt;Add&lt;/code&gt; methods:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BsonArray Add(BsonValue value)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonArray AddRange(IEnumerable&amp;lt;bool&amp;gt; values)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonArray AddRange(IEnumerable&amp;lt;BsonValue&amp;gt; values)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonArray AddRange(IEnumerable&amp;lt;DateTime&amp;gt; values)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonArray AddRange(IEnumerable&amp;lt;double&amp;gt; values)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonArray AddRange(IEnumerable&amp;lt;int&amp;gt; values)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonArray AddRange(IEnumerable&amp;lt;long&amp;gt; values)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonArray AddRange(IEnumerable&amp;lt;ObjectId&amp;gt; values)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonArray AddRange(IEnumerable&amp;lt;string&amp;gt; values)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BsonArray AddRange(IEnumerable values)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that the &lt;code&gt;Add&lt;/code&gt; method takes a single parameter. To create and
initialize a &lt;code&gt;BsonArray&lt;/code&gt; with multiple values use any of the following
approaches:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;// traditional approach
BsonArray a1 = new BsonArray();
a1.Add(1);
a2.Add(2);

// fluent interface
BsonArray a2 = new BsonArray().Add(1).Add(2);

// values argument
int[] values = new int[] { 1, 2 };
BsonArray a3 = new BsonArray(values);

// collection initializer syntax
BsonArray a4 = new BsonArray { 1, 2 };
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;indexer&#34;&gt;Indexer&lt;/h3&gt;

&lt;p&gt;Array elements are accessed using an integer index. Like &lt;code&gt;BsonDocument&lt;/code&gt;,
the type of the elements is &lt;code&gt;BsonValue&lt;/code&gt;. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonArray array = new BsonArray { &amp;quot;Tom&amp;quot;, 39 };
string name = array[0].AsString;
int age = array[1].AsInt32;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;lazybsondocument-and-lazybsonarray&#34;&gt;LazyBsonDocument and LazyBsonArray&lt;/h2&gt;

&lt;p&gt;The lazy classes are special in that they defer the deserialiation of
BSON until it is needed. This is useful for when you only need a field
or two out of a complex document because it will not incur the cost of
deserializing the entire document or array, but just the pieces that are
necessary. This deserialization occurs a level at a time. For example,
in the following document, asking for field &lt;code&gt;FirstName&lt;/code&gt; will deserialize
&lt;code&gt;LastName&lt;/code&gt; and &lt;code&gt;BirthDate&lt;/code&gt; as well, but it will leave &lt;code&gt;Addresses&lt;/code&gt; in its
serialized form until they are accessed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{
  FirstName: &amp;quot;Jack&amp;quot;,
  LastName: &amp;quot;McJack&amp;quot;,
  BirthDate: new ISODate(&amp;quot;...&amp;quot;),
  Addresses: [
     { Line1: &amp;quot;123 AnyStreet&amp;quot;, City: &amp;quot;Anytown&amp;quot; }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It can be used as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var db = server.GetDatabase(&amp;quot;foo&amp;quot;);
var col = db.GetCollection&amp;lt;LazyBsonDocument&amp;gt;(&amp;quot;bar&amp;quot;);

foreach (var doc in col.Find(Query.GT(&amp;quot;age&amp;quot;, 15)))
{
    using (doc)
    {
        // the first access will incur the cost of deserializing
        // FirstName, LastName, and BirthDate.  However,
        // Addresses will remain in its serialized form.
        var firstName = doc[&amp;quot;FirstName&amp;quot;];

        // this was already deserialized and is a simple
        // dictionary lookup.
        var lastName = doc[&amp;quot;LastName&amp;quot;];

        Console.WriteLine(&amp;quot;{0} {1}&amp;quot;, firstName, lastName);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;warning&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;LazyBsonDocument and LazyBsonArray implement IDisposable. It is very
important that these classes be disposed of to ensure high performance
and lower memory utilization.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;rawbsondocument-and-rawbsonarray&#34;&gt;RawBsonDocument and RawBsonArray&lt;/h2&gt;

&lt;p&gt;The raw classes are special in that they defer the deserialiation of
BSON until it is needed. This is useful for when you only need a field
or two out of a document and will not be accessing them repeatedly. The
Raw documents are best utilized when shuffling data from one database or
collection to another one in MongoDB or to another, external storage
location.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The behavior of the RawXXX classes differ from that of the LazyXXX
classes in that repeated access to the same field in the LazyXXX
version will not incur repeated deserialization overhead whereas the
RawXXX version will deserialize the same field without caching on
repeated requests.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It can be used as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var db = server.GetDatabase(&amp;quot;foo&amp;quot;);
var col = db.GetCollection&amp;lt;RawBsonDocument&amp;gt;(&amp;quot;bar&amp;quot;);

foreach (var doc in col.Find(Query.GT(&amp;quot;age&amp;quot;, 15)))
{
    using (doc)
    {
        // this access incurs the cost of deserializing
        // the FirstName element.
        var firstName = doc[&amp;quot;FirstName&amp;quot;];

        // even though this was deserialized just above,
        // it will need to get re-deserialized because
        // we do not store the results of deserialization.
        var firstNameAgain = doc[&amp;quot;FirstName&amp;quot;];

        Console.WriteLine(&amp;quot;{0} {1}&amp;quot;, doc[&amp;quot;FirstName&amp;quot;], doc[])
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The Raw classes are readonly and will throw exceptions if attempts are
made to update them.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;warning&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;RawBsonDocument and RawBsonArray implement IDisposable. It is very
important that these classes be disposed of to ensure high performance
and lower memory utilization.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;the-c-driver&#34;&gt;The C# Driver&lt;/h2&gt;

&lt;p&gt;Up until now we have been focusing on the BSON Library. The remainder of
this tutorial focuses on the C# Driver.&lt;/p&gt;

&lt;h2 id=&#34;thread-safety&#34;&gt;Thread Safety&lt;/h2&gt;

&lt;p&gt;Only a few of the C# Driver classes are thread safe. Among them:
&lt;code&gt;MongoClient&lt;/code&gt;, &lt;code&gt;MongoServer&lt;/code&gt;, &lt;code&gt;MongoDatabase&lt;/code&gt;, &lt;code&gt;MongoCollection&lt;/code&gt; and
&lt;code&gt;MongoGridFS&lt;/code&gt;. Common classes you will use a lot that are not thread
safe include &lt;code&gt;MongoCursor&lt;/code&gt; and all the classes from the BSON Library
(except &lt;code&gt;BsonSymbolTable&lt;/code&gt; which is thread safe). A class is not thread
safe unless specifically documented as being thread safe.&lt;/p&gt;

&lt;p&gt;All static properties and methods of all classes are thread safe.&lt;/p&gt;

&lt;h2 id=&#34;mongoclient-class&#34;&gt;&lt;code&gt;MongoClient&lt;/code&gt; Class&lt;/h2&gt;

&lt;p&gt;This class serves as the root object for working with a MongoDB server.
The connections to the server are handled automatically behind the
scenes (a connection pool is used to increase efficiency).&lt;/p&gt;

&lt;p&gt;When you are connecting to a replica set you will still use only one
instance of &lt;code&gt;MongoClient&lt;/code&gt;, which represents the replica set as a whole.
The driver automatically finds all the members of the replica set and
identifies the current primary.&lt;/p&gt;

&lt;p&gt;Instances of this class are thread safe.&lt;/p&gt;

&lt;p&gt;By default and unless set otherwise, all operations requiring a
&lt;code&gt;WriteConcern&lt;/code&gt; use &lt;code&gt;w=1&lt;/code&gt;. In other words, by default, all write
operations will block until the server has acknowledged the write.&lt;/p&gt;

&lt;h3 id=&#34;connection-strings&#34;&gt;Connection Strings&lt;/h3&gt;

&lt;p&gt;The easiest way to connect to a MongoDB server is to use a connection
string. The standard connection string format is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode none&#34;&gt;mongodb://[username:password@]hostname[:port][/[database][?options]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;username&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt; should only be present if you are using
authentication on the MongoDB server. The &lt;code&gt;database&lt;/code&gt; segment indicates
which database the &lt;code&gt;username&lt;/code&gt; is designated. When not specified, the
default &lt;code&gt;database&lt;/code&gt; is &lt;em&gt;admin&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If you are using the &lt;code&gt;database&lt;/code&gt; segment as the initial database to
use, but the username and password specified are defined in a
different database, you can use the &lt;code&gt;authSource&lt;/code&gt; option to specify the
database in which the credential is defined. For example,
mongodb://user:pass@hostname/db1?authSource=userDb would authenticate
the credential against the userDb database instead of db1.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;warning&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Versions prior to 1.8 of the driver allowed the specification of an
&lt;code&gt;admin&lt;/code&gt; credential by appending &lt;code&gt;(admin)&lt;/code&gt; to the username. This is not
recognized as of version 1.8. Consult the official &lt;a href=&#34;https://www.mongodb.com/docs/manual/reference/connection-string/&#34;&gt;connection string
documentation&lt;/a&gt;
for more information.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The port number is optional and defaults to &lt;code&gt;27017&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To connect to multiple servers, specify the seed list by providing
multiple hostnames (and port numbers if required) separated by commas.
For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode none&#34;&gt;mongodb://server1,server2:27017,server2:27018
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This connection string specifies a seed list consisting of three servers
(two of which are on the same machine but on different port numbers).
Because specifying multiple servers is ambiguous as to whether or not it
is a replica set or multiple mongos (in a sharded setup), the driver
will go through a discovery phase of connecting to the servers to
determine their type. This has a little overhead at connection time and
can be avoided by specifying a connection mode in the connection string:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;warning&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;It is required that each MongoDB server have a name that is DNS
resolvable by the client machine. Each MongoDB server reports its
hostname back through the isMaster command and the driver uses this
name to talk with the server. This issue can occur when the seed list
contains an IP address and the MongoDB server reports back a hostname
that the client machine is unable to resolve.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode none&#34;&gt;mongodb://server1,server2:27017,server2:27018/?connect=replicaset
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The available connection modes are automatic (the default), direct,
replica set, and shardrouter. The rules for connection mode are as
follows:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;If a connect mode is specified other than automatic, it is used.&lt;/li&gt;
&lt;li&gt;If the option replicaset is specified on the connection string using
literal &lt;code&gt;?connect=replicaset&lt;/code&gt; then replicaset mode is used. Don’t
use replica set name.&lt;/li&gt;
&lt;li&gt;If there is only one server listed on the connection string, then
direct mode is used.&lt;/li&gt;
&lt;li&gt;Otherwise, discovery occurs and the first server to respond
determines the connection mode.&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If you have multiple servers listed, and one is part of a replica set
and another is not, then the connection mode is non-deterministic. Be
sure that you are not mixing server types on the connection string.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Should the connection mode resolve to a replica set, the driver will
find the primary server even if it is not in the seed list, as long as
at least one of the servers in the seed list responds (the response will
contain the full replica set and the name of the current primary). In
addition, other secondaries will also be discovered and added (or
removed) into the mix automatically, even after initial connection. This
will enable you to add and remove servers from the replica set and the
driver will handle the changes automatically.&lt;/p&gt;

&lt;p&gt;As alluded to above, the options part of the connection string is used
to set various connection options. Suppose you wanted to connect
directly to a member of a replica set regardless of whether it was the
current primary or not (perhaps to monitor its status or to issue read
only queries against it). You could use:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode none&#34;&gt;mongodb://server2/?connect=direct;readpreference=nearest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The full documentation for connection strings can be found at
&lt;a href=&#34;https://www.mongodb.com/docs/manual/reference/connection-string/&#34;&gt;Connection
String&lt;/a&gt; and
read preferences at
&lt;a href=&#34;https://www.mongodb.com/docs/manual/applications/replication/#replica-set-read-preference&#34;&gt;https://www.mongodb.com/docs/manual/applications/replication/#replica-set-read-preference&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;ssl-support&#34;&gt;SSL Support&lt;/h3&gt;

&lt;p&gt;Support for SSL is baked into the driver. You can configure this via the
connection string be adding an &lt;code&gt;ssl=true&lt;/code&gt; option to the options.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode none&#34;&gt;mongodb://server2/?ssl=true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default, the server certificate will get validated against the local
trusted certificate store. This sometimes causes issues in test
environments where test servers don&amp;rsquo;t have signed certs. To alleviate
this issue, you can also add an &lt;code&gt;sslverifycertificate=false&lt;/code&gt; as another
connection string option to ignore any certificate errors.&lt;/p&gt;

&lt;p&gt;In addition to the above connection string settings, there are a number
of settings that can be utilized through code. The &lt;code&gt;SslSettings&lt;/code&gt; class
is the container of these settings.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CheckCertificateRevocation: defaults to false. *
ClientCertificates: see
&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh159283.aspx&#34;&gt;MSDN&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;ClientCertificateSelectionCallback: see &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/system.net.security.localcertificateselectioncallback.aspx&#34;&gt;MSDN
LocalCertificateSelectionCallback&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;EnabledSslProtocols: see
&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/hh159283.aspx&#34;&gt;MSDN&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;ServerCertificateValidationCallback: see &lt;a href=&#34;http://msdn.microsoft.com/en-us/library/system.net.security.remotecertificatevalidationcallback.aspx&#34;&gt;MSDN
RemoteCertificateValidationCallback&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To set these values, create a new instance of &lt;code&gt;SslSettings&lt;/code&gt;, assign it
values, and then add it to an instance of &lt;code&gt;MongoClientSettings&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var sslSettings = new SslSettings
{
    CheckCertificateRevocation = true
};
var clientSettings = new MongoClientSettings
{
    SslSettings = sslSettings
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;authentication&#34;&gt;Authentication&lt;/h3&gt;

&lt;p&gt;The .NET driver supports both MongoDB&amp;rsquo;s authentication simple protocol
as well as the more complex and robust Kerberos protocol. This enables
the driver to function with single-sign-on functionality against a
Kerberose Key Distribution Center. One such KDC is Active Directory. See
below for more details:&lt;/p&gt;

&lt;p&gt;/tutorial/authenticate-with-csharp-driver&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;warning&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Version 2.4 of the server supports &lt;a href=&#34;https://www.mongodb.com/docs/manual/reference/privilege-documents/#delegated-credentials-for-mongodb-authentication&#34;&gt;Delegated
Authentication&lt;/a&gt;.
Due to this change, the 1.8 release of the driver has some backwards
breaking changes in order to support this feature. Most importantly,
all the credentials supplied in a MongoClientSettings instance will be
authenticated when a new connection is opened, regardless of the
database you are currently using.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;getserver-method&#34;&gt;&lt;code&gt;GetServer&lt;/code&gt; Method&lt;/h3&gt;

&lt;p&gt;You can navigate from an instance of a &lt;code&gt;MongoClient&lt;/code&gt; to an instance of
&lt;code&gt;MongoServer&lt;/code&gt; by using the &lt;code&gt;GetServer&lt;/code&gt; method.&lt;/p&gt;

&lt;h2 id=&#34;mongoserver-class&#34;&gt;&lt;code&gt;MongoServer&lt;/code&gt; Class&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;MongoServer&lt;/code&gt; class is used to provide more control over the driver.
It contains advanced ways of getting a database and pushing a sequence
of operations through a single socket in order to guarantee consistency.&lt;/p&gt;

&lt;h3 id=&#34;getdatabase-method&#34;&gt;&lt;code&gt;GetDatabase&lt;/code&gt; Method&lt;/h3&gt;

&lt;p&gt;You can navigate from an instance of &lt;code&gt;MongoServer&lt;/code&gt; to an instance of
&lt;code&gt;MongoDatabase&lt;/code&gt; (see next section) using one of the following
&lt;code&gt;GetDatabase&lt;/code&gt; methods or indexers:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MongoDatabase GetDatabase(MongoDatabaseSettings settings)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MongoDatabase GetDatabase(string databaseName)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MongoDatabase GetDatabase(string databaseName, MongoCredentials credentials)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MongoDatabase GetDatabase(string databaseName, MongoCredentials credentials, WriteConcern writeConcern)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MongoDatabase GetDatabase(string databaseName, WriteConcern writeConcern)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sample code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;MongoClient client = new MongoClient(); // connect to localhost
MongoServer server = client.GetServer();
MongoDatabase test = server.GetDatabase(&amp;quot;test&amp;quot;);
MongoCredentials credentials = new MongoCredentials(&amp;quot;username&amp;quot;, &amp;quot;password&amp;quot;);
MongoDatabase salaries = server.GetDatabase(&amp;quot;salaries&amp;quot;, credentials);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most of the database settings are inherited from the server object, and
the provided overloads of &lt;code&gt;GetDatabase&lt;/code&gt; let you override a few of the
most commonly used settings. To override other settings, call
&lt;code&gt;CreateDatabaseSettings&lt;/code&gt; and change any settings you want before calling
&lt;code&gt;GetDatabase&lt;/code&gt;, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var databaseSettings = server.CreateDatabaseSettings(&amp;quot;test&amp;quot;);
databaseSettings.SlaveOk = true;
var database = server.GetDatabase(databaseSettings);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;GetDatabase&lt;/code&gt; maintains a table of MongoDatabase instances it has
returned before, so if you call &lt;code&gt;GetDatabase&lt;/code&gt; again with the same
parameters you get the same instance back again.&lt;/p&gt;

&lt;h3 id=&#34;requeststart-requestdone-methods&#34;&gt;&lt;code&gt;RequestStart&lt;/code&gt;/&lt;code&gt;RequestDone&lt;/code&gt; Methods&lt;/h3&gt;

&lt;p&gt;Sometimes a series of operations needs to be performed on the same
connection in order to guarantee correct results. This is rarely the
case, and most of the time there is no need to call
&lt;code&gt;RequestStart&lt;/code&gt;/&lt;code&gt;RequestDone&lt;/code&gt;. An example of when this might be necessary
is when a series of &lt;code&gt;Inserts&lt;/code&gt; are called in rapid succession with a
&lt;code&gt;WriteConcern&lt;/code&gt; of &lt;code&gt;w=0&lt;/code&gt;, and you want to query that data is in a
consistent manner immediately thereafter (with a &lt;code&gt;WriteConcern&lt;/code&gt; of
&lt;code&gt;w=0&lt;/code&gt;, the writes can queue up at the server and might not be
immediately visible to other connections). Using &lt;code&gt;RequestStart&lt;/code&gt; you can
force a query to be on the same connection as the writes, so the query
won&amp;rsquo;t execute until the server has caught up with the writes.&lt;/p&gt;

&lt;p&gt;A thread can temporarily reserve a connection from the connection pool
by using &lt;code&gt;RequestStart&lt;/code&gt; and &lt;code&gt;RequestDone&lt;/code&gt;. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;using(server.RequestStart(database)) {
// a series of operations that must be performed on the same connection
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The database parameter simply indicates some database which you intend
to use during this request. This allows the server to pick a connection
that is already authenticated for that database (if you are not using
authentication then this optimization won&amp;rsquo;t matter to you). You are free
to use any other databases as well during the request.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RequestStart&lt;/code&gt; increments a counter (for this thread) which is
decremented upon completion. The connection that was reserved is not
actually returned to the connection pool until the count reaches zero
again. This means that calls to &lt;code&gt;RequestStart&lt;/code&gt; can be nested and the
right thing will happen.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;RequestStart&lt;/code&gt; returns an &lt;code&gt;IDisposable&lt;/code&gt;. If you do not use
&lt;code&gt;RequestStart&lt;/code&gt; with a &lt;code&gt;using&lt;/code&gt; block, it is imperative that
&lt;code&gt;RequestDone&lt;/code&gt; be called in order to release the connection.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;other-properties-and-methods&#34;&gt;Other Properties and Methods&lt;/h3&gt;

&lt;p&gt;For a reference of other properties and method, see the api
documentation.&lt;/p&gt;

&lt;h2 id=&#34;mongodatabase-class&#34;&gt;MongoDatabase Class&lt;/h2&gt;

&lt;p&gt;This class represents a database on a MongoDB server. Normally there
will be only one instance of this class per database, unless you are
using different settings to access the same database, in which case
there will be one instance for each set of settings.&lt;/p&gt;

&lt;p&gt;Instances of this class are thread safe.&lt;/p&gt;

&lt;h3 id=&#34;getcollection-method&#34;&gt;&lt;code&gt;GetCollection&lt;/code&gt; Method&lt;/h3&gt;

&lt;p&gt;This method returns an object representing a collection in a database.
When we request a collection object, we also specify the default
document type for the collection. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;MongoDatabase hr = server.GetDatabase(&amp;quot;hr&amp;quot;);
MongoCollection&amp;lt;Employee&amp;gt; employees =
    hr.GetCollection&amp;lt;Employee&amp;gt;(&amp;quot;employees&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A collection is not restricted to containing only one kind of document.
The default document type simply makes it more convenient to work with
that kind of document, but you can always specify a different kind of
document when required.&lt;/p&gt;

&lt;p&gt;Most of the collection settings are inherited from the database object,
and the provided overloads of &lt;code&gt;GetCollection&lt;/code&gt; let you override a few of
the most commonly used settings. To override other settings, call
&lt;code&gt;CreateCollectionSettings&lt;/code&gt; and change any settings you want before
calling &lt;code&gt;GetCollection&lt;/code&gt; , like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var collectionSettings = database.CreateCollectionSettings&amp;lt;TDocument&amp;gt;(&amp;quot;test&amp;quot;);
collectionSettings.SlaveOk = true;
var collection = database.GetCollection(collectionSettings);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;GetCollection&lt;/code&gt; maintains a table of instances it has returned before,
so if you call &lt;code&gt;GetCollection&lt;/code&gt; again with the same parameters you get
the same instance back again.&lt;/p&gt;

&lt;h3 id=&#34;other-properties-and-methods-1&#34;&gt;Other Properties and Methods&lt;/h3&gt;

&lt;p&gt;For a reference of other properties and method, see the api
documentation.&lt;/p&gt;

&lt;h2 id=&#34;mongocollection-tdefaultdocument-class&#34;&gt;&lt;code&gt;MongoCollection&amp;lt;TDefaultDocument&amp;gt;&lt;/code&gt; Class&lt;/h2&gt;

&lt;p&gt;This class represents a collection in a MongoDB database. The
&lt;code&gt;&amp;lt;TDefaultDocument&amp;gt;&lt;/code&gt; type parameter specifies the type of the default
document for this collection.&lt;/p&gt;

&lt;p&gt;Instances of this class are thread safe.&lt;/p&gt;

&lt;h3 id=&#34;insert-tdocument-method&#34;&gt;&lt;code&gt;Insert&amp;lt;TDocument&amp;gt;&lt;/code&gt; Method&lt;/h3&gt;

&lt;p&gt;To insert a document in the collection create an object representing the
document and call &lt;code&gt;Insert&lt;/code&gt;. The object can be an instance of
&lt;code&gt;BsonDocument&lt;/code&gt; or of any class that can be successfully serialized as a
BSON document. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;MongoCollection&amp;lt;BsonDocument&amp;gt; books =
    database.GetCollection&amp;lt;BsonDocument&amp;gt;(&amp;quot;books&amp;quot;);
BsonDocument book = new BsonDocument {
    { &amp;quot;author&amp;quot;, &amp;quot;Ernest Hemingway&amp;quot; },
    { &amp;quot;title&amp;quot;, &amp;quot;For Whom the Bell Tolls&amp;quot; }
};
books.Insert(book);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you have a class called &lt;code&gt;Book&lt;/code&gt; the code might look like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;MongoCollection&amp;lt;Book&amp;gt; books = database.GetCollection&amp;lt;Book&amp;gt;(&amp;quot;books&amp;quot;);
Book book = new Book {
    Author = &amp;quot;Ernest Hemingway&amp;quot;,
    Title = &amp;quot;For Whom the Bell Tolls&amp;quot;
};
books.Insert(book);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;insertbatch-method&#34;&gt;&lt;code&gt;InsertBatch&lt;/code&gt; Method&lt;/h3&gt;

&lt;p&gt;You can insert more than one document at a time using the &lt;code&gt;InsertBatch&lt;/code&gt;
method. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;MongoCollection&amp;lt;BsonDocument&amp;gt; books;
BsonDocument[] batch = {
    new BsonDocument {
        { &amp;quot;author&amp;quot;, &amp;quot;Kurt Vonnegut&amp;quot; },
        { &amp;quot;title&amp;quot;, &amp;quot;Cat&#39;s Cradle&amp;quot; }
    },
    new BsonDocument {
        { &amp;quot;author&amp;quot;, &amp;quot;Kurt Vonnegut&amp;quot; },
        { &amp;quot;title&amp;quot;, &amp;quot;Slaughterhouse-Five&amp;quot; }
    }
};
books.InsertBatch(batch);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you are inserting multiple documents &lt;code&gt;InsertBatch&lt;/code&gt; can be much more
efficient than &lt;code&gt;Insert&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;findone-and-findoneas-methods&#34;&gt;&lt;code&gt;FindOne&lt;/code&gt; and &lt;code&gt;FindOneAs&lt;/code&gt; Methods&lt;/h3&gt;

&lt;p&gt;To retrieve documents from a collection use one of the various &lt;code&gt;Find&lt;/code&gt;
methods. &lt;code&gt;FindOne&lt;/code&gt; is the simplest. It returns the first document it
finds (when there are many documents in a collection you can&amp;rsquo;t be sure
which one it will be). For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;MongoCollection&amp;lt;Book&amp;gt; books;
Book book = books.FindOne();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to read a document that is not of the &lt;code&gt;&amp;lt;TDefaultDocument&amp;gt;&lt;/code&gt;
type use the &lt;code&gt;FindOneAs&lt;/code&gt; method, which allows you to override the type
of the returned document. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;MongoCollection&amp;lt;Book&amp;gt; books;
BsonDocument document = books.FindOneAs&amp;lt;BsonDocument&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case the default document type of the collection is &lt;code&gt;Book&lt;/code&gt;, but
we are overriding that and specifying that the result be returned as an
instance of &lt;code&gt;BsonDocument&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;find-and-findas-methods&#34;&gt;&lt;code&gt;Find&lt;/code&gt; and &lt;code&gt;FindAs&lt;/code&gt; Methods&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;Find&lt;/code&gt; and &lt;code&gt;FindAs&lt;/code&gt; methods take a query that tells the server which
documents to return. The query parameter is of type &lt;code&gt;IMongoQuery&lt;/code&gt;.
&lt;code&gt;IMongoQuery&lt;/code&gt; is a marker interface that identifies classes that can be
used as queries. The most common ways to construct a query are to either
use the &lt;code&gt;Query&lt;/code&gt; builder class or to create a &lt;code&gt;QueryDocument&lt;/code&gt; yourself (a
&lt;code&gt;QueryDocument&lt;/code&gt; is a subclass of &lt;code&gt;BsonDocument&lt;/code&gt; that also implements
&lt;code&gt;IMongoQuery&lt;/code&gt; and can therefore be used as a query object).&lt;/p&gt;

&lt;p&gt;One way to query is to create a &lt;code&gt;QueryDocument&lt;/code&gt; object yourself:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;MongoCollection&amp;lt;BsonDocument&amp;gt; books;
var query = new QueryDocument(&amp;quot;author&amp;quot;, &amp;quot;Kurt Vonnegut&amp;quot;);
foreach (BsonDocument book in books.Find(query)) {
    // do something with book
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another way to query is to use the Query Builder (recommended):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;MongoCollection&amp;lt;BsonDocument&amp;gt; books;
var query = Query.EQ(&amp;quot;author&amp;quot;, &amp;quot;Kurt Vonnegut&amp;quot;);
foreach (BsonDocument book in books.Find(query)) {
    // do something with book
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to read a document of a type that is not the default
document type use the &lt;code&gt;FindAs&lt;/code&gt; method instead:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;MongoCollection&amp;lt;BsonDocument&amp;gt; books;
var query = Query&amp;lt;Book&amp;gt;.EQ(b =&amp;gt; b.Author, &amp;quot;Kurt Vonnegut&amp;quot;);
foreach (Book book in books.FindAs&amp;lt;Book&amp;gt;(query)) {
    // do something with book
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;save-tdocument-method&#34;&gt;&lt;code&gt;Save&amp;lt;TDocument&amp;gt;&lt;/code&gt; Method&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;Save&lt;/code&gt; method is a combination of &lt;code&gt;Insert&lt;/code&gt; and &lt;code&gt;Update&lt;/code&gt;. If the &lt;code&gt;Id&lt;/code&gt;
member of the document has a value, then it is assumed to be an existing
document and &lt;code&gt;Save&lt;/code&gt; calls &lt;code&gt;Update&lt;/code&gt; on the document (setting the &lt;code&gt;Upsert&lt;/code&gt;
flag just in case it actually is a new document after all). Otherwise it
is assumed to be a new document and &lt;code&gt;Save&lt;/code&gt; calls &lt;code&gt;Insert&lt;/code&gt; after first
assigning a newly generated unique value to the &lt;code&gt;Id&lt;/code&gt; member.&lt;/p&gt;

&lt;p&gt;For example, you could correct an error in the title of a book using:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;MongoCollection&amp;lt;BsonDocument&amp;gt; books;
var query = Query.And(
    Query.EQ(&amp;quot;author&amp;quot;, &amp;quot;Kurt Vonnegut&amp;quot;),
    Query.EQ(&amp;quot;title&amp;quot;, &amp;quot;Cats Craddle&amp;quot;)
);
BsonDocument book = books.FindOne(query);
if (book != null) {
    book[&amp;quot;title&amp;quot;] = &amp;quot;Cat&#39;s Cradle&amp;quot;;
    books.Save(book);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;TDocument&lt;/code&gt; class must have an &lt;code&gt;Id&lt;/code&gt; member to be used with the
&lt;code&gt;Save&lt;/code&gt; method. If it does not you can call &lt;code&gt;Insert&lt;/code&gt; instead of &lt;code&gt;Save&lt;/code&gt; to
insert the document.&lt;/p&gt;

&lt;h3 id=&#34;update-method&#34;&gt;&lt;code&gt;Update&lt;/code&gt; Method&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;Update&lt;/code&gt; method is used to update existing documents. The code
sample shown for the &lt;code&gt;Save&lt;/code&gt; method could also have been written as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;MongoCollection&amp;lt;BsonDocument&amp;gt; books;
var query = new QueryDocument {
    { &amp;quot;author&amp;quot;, &amp;quot;Kurt Vonnegut&amp;quot; },
    { &amp;quot;title&amp;quot;, &amp;quot;Cats Craddle&amp;quot; }
};
var update = new UpdateDocument {
    { &amp;quot;$set&amp;quot;, new BsonDocument(&amp;quot;title&amp;quot;, &amp;quot;Cat&#39;s Cradle&amp;quot;) }
};
BsonDocument updatedBook = books.Update(query, update);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or using &lt;code&gt;Query&lt;/code&gt; and &lt;code&gt;Update&lt;/code&gt; builders:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;MongoCollection&amp;lt;BsonDocument&amp;gt; books;
var query = Query.And(
    Query.EQ(&amp;quot;author&amp;quot;, &amp;quot;Kurt Vonnegut&amp;quot;),
    Query.EQ(&amp;quot;title&amp;quot;, &amp;quot;Cats Craddle&amp;quot;)
);
var update = Update.Set(&amp;quot;title&amp;quot;, &amp;quot;Cat&#39;s Cradle&amp;quot;);
BsonDocument updatedBook = books.Update(query, update);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;findandmodify-method&#34;&gt;&lt;code&gt;FindAndModify&lt;/code&gt; Method&lt;/h3&gt;

&lt;p&gt;Use &lt;code&gt;FindAndModify&lt;/code&gt; when you want to find a matching document and update
it in one atomic operation. &lt;code&gt;FindAndModify&lt;/code&gt; always updates a single
document, and you can combine a query that matches multiple documents
with a sort criteria that will determine exactly which matching document
is updated. In addition, &lt;code&gt;FindAndModify&lt;/code&gt; will return the matching
document (either as it was before the update or after) and if you wish
you can specify which fields of the matching document to return.&lt;/p&gt;

&lt;p&gt;Using the example documented here, &lt;a href=&#34;https://www.mongodb.com/docs/manual/reference/command/findAndModify/&#34;&gt;findAndModify
Command&lt;/a&gt;,
the call to &lt;code&gt;FindAndModify&lt;/code&gt; would be written in C# as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var jobs = database.GetCollection(&amp;quot;jobs&amp;quot;);
var query = Query.And(
    Query.EQ(&amp;quot;inprogress&amp;quot;, false),
    Query.EQ(&amp;quot;name&amp;quot;, &amp;quot;Biz report&amp;quot;)
);
var sortBy = SortBy.Descending(&amp;quot;priority&amp;quot;);
var update = Update.
    .Set(&amp;quot;inprogress&amp;quot;, true)
    .Set(&amp;quot;started&amp;quot;, DateTime.UtcNow);
var result = jobs.FindAndModify(
    query,
    sortBy,
    update,
    true // return new document
);
var chosenJob = result.ModifiedDocument;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mapreduce-method&#34;&gt;&lt;code&gt;MapReduce&lt;/code&gt; Method&lt;/h3&gt;

&lt;p&gt;Map/Reduce is a way of aggregating data from a collection. Every
document in a collection (or some subset if an optional query is
provided) is sent to the &lt;code&gt;map&lt;/code&gt; function, which calls &lt;code&gt;emit&lt;/code&gt; to produce
intermediate values. The intermediate values are then sent to the
&lt;code&gt;reduce&lt;/code&gt; function to be aggregated.&lt;/p&gt;

&lt;p&gt;This example is taken from page 87 of &lt;strong&gt;MongoDB: The Definitive Guide&lt;/strong&gt;,
by Kristina Chodorow and Michael Dirolf. It counts how many times each
key is found in a collection.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var map =
    &amp;quot;function() {&amp;quot; +
    &amp;quot;    for (var key in this) {&amp;quot; +
    &amp;quot;        emit(key, { count : 1 });&amp;quot; +
    &amp;quot;    }&amp;quot; +
    &amp;quot;}&amp;quot;;

var reduce =
    &amp;quot;function(key, emits) {&amp;quot; +
    &amp;quot;    total = 0;&amp;quot; +
    &amp;quot;    for (var i in emits) {&amp;quot; +
    &amp;quot;        total += emits[i].count;&amp;quot; +
    &amp;quot;    }&amp;quot; +
    &amp;quot;    return { count : total };&amp;quot; +
    &amp;quot;}&amp;quot;;

var mr = collection.MapReduce(map, reduce);
foreach (var document in mr.GetResults()) {
    Console.WriteLine(document.ToJson());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;other-properties-and-methods-2&#34;&gt;Other Properties and Methods&lt;/h3&gt;

&lt;p&gt;For a reference of other properties and method, see the api
documentation.&lt;/p&gt;

&lt;h2 id=&#34;mongocursor-tdocument-class&#34;&gt;&lt;code&gt;MongoCursor&amp;lt;TDocument&amp;gt;&lt;/code&gt; Class&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;Find&lt;/code&gt; method (and its variations) don&amp;rsquo;t immediately return the
actual results of a query. Instead they return a cursor that can be
enumerated to retrieve the results of the query. The query isn&amp;rsquo;t
actually sent to the server until we attempt to retrieve the first
result (technically, when &lt;code&gt;MoveNext&lt;/code&gt; is called for the first time on the
enumerator returned by &lt;code&gt;GetEnumerator&lt;/code&gt;). This means that we can control
the results of the query in interesting ways by modifying the cursor
before fetching the results.&lt;/p&gt;

&lt;p&gt;Instances of &lt;code&gt;MongoCursor&lt;/code&gt; are not thread safe, at least not until they
are frozen (see below). Once they are frozen they are thread safe
because they are read-only (in particular, &lt;code&gt;GetEnumerator&lt;/code&gt; is thread
safe so the same cursor &lt;em&gt;could&lt;/em&gt; be used by multiple threads).&lt;/p&gt;

&lt;h3 id=&#34;enumerating-a-cursor&#34;&gt;Enumerating a cursor&lt;/h3&gt;

&lt;p&gt;The most convenient way to consume the results of a query is to use the
C# foreach statement. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query = Query.EQ(&amp;quot;author&amp;quot;, &amp;quot;Ernest Hemingway&amp;quot;);
var cursor = books.Find(query);
foreach (var book in cursor) {
    // do something with book
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also use any of the extensions methods defined by LINQ for
&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; to enumerate a cursor:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query = Query.EQ(&amp;quot;author&amp;quot;, &amp;quot;Ernest Hemingway&amp;quot;);
var cursor = books.Find(query);
var firstBook = cursor.FirstOrDefault();
var lastBook = cursor.LastOrDefault();
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In the above example, the query is actually sent to the server twice
(once when &lt;code&gt;FirstOrDefault&lt;/code&gt; is called and again when &lt;code&gt;LastOrDefault&lt;/code&gt;
is called).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It is important that a cursor cleanly release any resources it holds.
The key to guaranteeing this is to make sure the &lt;code&gt;Dispose&lt;/code&gt; method of the
enumerator is called. The &lt;code&gt;foreach&lt;/code&gt; statement and the LINQ extension
methods all guarantee that &lt;code&gt;Dispose&lt;/code&gt; will be called. Only if you
enumerate the cursor manually are you responsible for calling &lt;code&gt;Dispose&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;modifying-a-cursor-before-enumerating-it&#34;&gt;Modifying a Cursor Before Enumerating It&lt;/h3&gt;

&lt;p&gt;A cursor has several properties that can be modified before it is
enumerated to control the results returned. There are two ways to modify
a cursor:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Modify the properties directly.&lt;/li&gt;
&lt;li&gt;Use the fluent interface to set the properties.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For example, if we want to skip the first 100 results and limit the
results to the next 10, we could write:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query = Query.EQ(&amp;quot;status&amp;quot;, &amp;quot;pending&amp;quot;);
var cursor = tasks.Find(query);
cursor.Skip = 100;
cursor.Limit = 10;
foreach (var task in cursor) {
    // do something with task
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or using the fluent interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query = Query.EQ(&amp;quot;status&amp;quot;, &amp;quot;pending&amp;quot;);
foreach (var task in tasks.Find(query).SetSkip(100).SetLimit(10)) {
    // do something with task
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The fluent interface works well when you are setting only a few values.
When setting more than a few you might prefer to use the properties
approach.&lt;/p&gt;

&lt;p&gt;Once you begin enumerating a cursor it becomes &amp;ldquo;frozen&amp;rdquo; and you can no
longer change any of its properties. So you must set all the properties
before you start enumerating it.&lt;/p&gt;

&lt;h3 id=&#34;modifiable-properties-of-a-cursor&#34;&gt;Modifiable Properties of a Cursor&lt;/h3&gt;

&lt;p&gt;The following properties of a cursor are modifiable:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BatchSize&lt;/code&gt; (&lt;code&gt;SetBatchSize&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Fields&lt;/code&gt; (&lt;code&gt;SetFields&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Flags&lt;/code&gt; (&lt;code&gt;SetFlags&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Limit&lt;/code&gt; (&lt;code&gt;SetLimit&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Options&lt;/code&gt; (&lt;code&gt;SetOption&lt;/code&gt; and &lt;code&gt;SetOptions&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SerializationOptions&lt;/code&gt; (&lt;code&gt;SetSerializationOptions&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Skip&lt;/code&gt; (&lt;code&gt;SetSkip&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SlaveOk&lt;/code&gt; (&lt;code&gt;SetSlaveOk&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The names in parenthesis are the corresponding fluent interface method
names.&lt;/p&gt;

&lt;p&gt;The fluent interface also supports additional options that aren&amp;rsquo;t used
very frequently and are not exposed as properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SetHint&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SetMax&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SetMaxScan&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SetMaxTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SetMin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SetShowDiskLoc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SetSnapshot&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SetSortOrder&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;other-methods&#34;&gt;Other Methods&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;MongoCursor&lt;/code&gt; has a few methods used for some special purpose
operations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Clone&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Count&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Explain&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Size&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;writeconcern-class&#34;&gt;&lt;code&gt;WriteConcern&lt;/code&gt; Class&lt;/h2&gt;

&lt;p&gt;There are various levels of &lt;code&gt;WriteConcern&lt;/code&gt;, and this class is used to
represent those levels. &lt;code&gt;WriteConcern&lt;/code&gt; applies only to operations that
don&amp;rsquo;t already return a value (so it doesn&amp;rsquo;t apply to queries or
commands). It applies to the following &lt;code&gt;MongoCollection&lt;/code&gt; methods:
&lt;code&gt;Insert&lt;/code&gt;, &lt;code&gt;Remove&lt;/code&gt;, &lt;code&gt;Save&lt;/code&gt; and &lt;code&gt;Update&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The gist of &lt;code&gt;WriteConcern&lt;/code&gt; is that after an &lt;code&gt;Insert&lt;/code&gt;, &lt;code&gt;Remove&lt;/code&gt;, &lt;code&gt;Save&lt;/code&gt;
or &lt;code&gt;Update&lt;/code&gt; message is sent to the server it is followed by a
&lt;code&gt;GetLastError&lt;/code&gt; command so the driver can verify that the operation
succeeded. In addition, when using replica sets it is possible to verify
that the information has been replicated to some minimum number of
secondary servers.&lt;/p&gt;

&lt;h2 id=&#34;maxtime&#34;&gt;&lt;code&gt;MaxTime&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;MongoDB 2.6 introduced the ability to timeout individual queries:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;coll.FindAll().SetMaxTime(TimeSpan.FromSeconds(1));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example above the maxTimeMS is set to one second and the query
will be aborted after the full second is up.&lt;/p&gt;

&lt;h3 id=&#34;bulk-operations&#34;&gt;Bulk operations&lt;/h3&gt;

&lt;p&gt;Under the covers MongoDB is moving away from the combination of a write
operation followed by get last error (GLE) and towards a write commands
API. These new commands allow for the execution of bulk
insert/update/remove operations. There are two types of bulk operations:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Ordered bulk operations.&lt;/p&gt;

&lt;p&gt;:   Executes all the operations in order and error out on the first
    write error.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unordered bulk operations.&lt;/p&gt;

&lt;p&gt;:   Executes all the operations in parallel and aggregates all the
    errors. Unordered bulk operations do not guarantee order of
    execution.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let&amp;rsquo;s look at two simple examples using ordered and unordered
operations:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;// 1. Ordered bulk operation
var bulk = coll.InitializeOrderedBulkOperation();
bulk.Insert(new BsonDocument(&amp;quot;_id&amp;quot;, 1));
bulk.Insert(new BsonDocument(&amp;quot;_id&amp;quot;, 2));
bulk.Insert(new BsonDocument(&amp;quot;_id&amp;quot;, 3));

bulk.Find(Query.EQ(&amp;quot;_id&amp;quot;, 1)).UpdateOne(Update.Set(&amp;quot;x&amp;quot;, 2)));
bulk.Find(Query.EQ(&amp;quot;_id&amp;quot;, 2)).RemoveOne();
bulk.Find(Query.EQ(&amp;quot;_id&amp;quot;, 3)).ReplaceOne(Update.Replace(new BsonDocument(&amp;quot;_id&amp;quot;, 3).Add(&amp;quot;x&amp;quot;, 4)));

BulkWriteResult result = bulk.Execute();

// 2. Unordered bulk operation - no guarantee of order of operation
bulk = coll.InitializeUnorderedBulkOperation();
bulk.Find(Query.EQ(&amp;quot;_id&amp;quot;, 1)).RemoveOne();
bulk.Find(Query.EQ(&amp;quot;_id&amp;quot;, 2)).RemoveOne();

result = bulk.Execute();
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For servers older than 2.6 the API will down-convert the operations.
To support the correct semantics for BulkWriteResult and
BulkWriteException, the operations have to be done one at a time. It&amp;rsquo;s
not possible to down convert 100% so there might be slight edge cases
where it cannot correctly report the right numbers.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;parallelscan&#34;&gt;ParallelScan&lt;/h3&gt;

&lt;p&gt;MongoDB 2.6 added the &lt;code&gt;parallelCollectionScan&lt;/code&gt; command that allows
reading an entire collection using multiple cursors.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var args = new ParallelScanArgs&amp;lt;BsonDocument&amp;gt;
{
   NumberOfCursors = 3,
   BatchSize = 300
};

var cursors = coll.ParallelScan(args);
for (var cursor in cursors) 
{
    using(cursor) // need to close the cursor when we are done
    {
      while (cursor.MoveNext()) 
      {
          Console.WriteLine(cursor.Current);
      }
    }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In practice, one thread per cursor would be used such that each cursor
is enumerated in parallel.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ParallelScan does not work via mongos.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>LINQ Tutorial</title>
      <link>/mongo-csharp-driver/1.11/linq/</link>
      <pubDate>Wed, 18 Mar 2015 16:56:14 +0000</pubDate>
      
      <guid>/mongo-csharp-driver/1.11/linq/</guid>
      <description>

&lt;h1 id=&#34;linq-tutorial&#34;&gt;LINQ Tutorial&lt;/h1&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;This tutorial covers the support for LINQ queries as of the 1.8 release
of the C# driver.&lt;/p&gt;

&lt;p&gt;You should already have read at least the &lt;a href=&#34;/mongo-csharp-driver/1.11/mongo-csharp-driver/1.11/driver/&#34;&gt;Driver Tutorial&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;quickstart&#34;&gt;Quickstart&lt;/h2&gt;

&lt;p&gt;First, add the following additional using statement to your program:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;using MongoDB.Driver.Linq;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, get a reference to a collection variable in the usual way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var collection = database.GetCollection&amp;lt;TDocument&amp;gt;(&amp;quot;collectionname&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The basic idea behind writing a LINQ query is to start from a collection
variable and begin the LINQ query by calling the
&lt;code&gt;AsQueryable&amp;lt;TDocument&amp;gt;()&lt;/code&gt; method. After that it&amp;rsquo;s all standard LINQ.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from e in collection.AsQueryable&amp;lt;Employee&amp;gt;()
    where e.FirstName == &amp;quot;John&amp;quot;
    select e;

foreach (var employee in query)
{
    // process employees named &amp;quot;John&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also write queries using lambda syntax. The previous query would
be written using lambda syntax like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    collection.AsQueryable&amp;lt;Employee&amp;gt;()
    .Where(e =&amp;gt; e.FirstName == &amp;quot;John&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The C# compiler translates all queries written using query syntax into
lambda syntax internally anyway, so there is no performance advantage or
penalty to choosing either style. You can also mix and match the styles,
which can be useful when using query operators that are not supported by
the query syntax.&lt;/p&gt;

&lt;p&gt;All the code samples in this tutorial show both the query syntax and the
lambda syntax for each query operator and supported where clauses.&lt;/p&gt;

&lt;p&gt;Only LINQ queries that can be translated to an equivalent MongoDB query
are supported. If you write a LINQ query that can&amp;rsquo;t be translated you
will get a runtime exception and the error message will indicate which
part of the query wasn&amp;rsquo;t supported.&lt;/p&gt;

&lt;h2 id=&#34;supported-linq-query-operators&#34;&gt;Supported LINQ query operators&lt;/h2&gt;

&lt;p&gt;This section documents the supported LINQ query operators.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Without a predicate &lt;code&gt;Any&lt;/code&gt; just tests whether the collection has any
documents.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    select c)
    .Any();
// or
var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Any();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Any (with predicate)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;With a predicate &lt;code&gt;Any&lt;/code&gt; tests whether the collection has any matching
documents.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    select c)
    .Any(c =&amp;gt; c.X == 1);
// or
var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Any(c =&amp;gt; c.X == 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Any&lt;/code&gt; with a predicate is not supported after a projection (at least
not yet). So the following is not valid:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Select(c =&amp;gt; c.X)
    .Any(x =&amp;gt; x == 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can usually rewrite such a query by putting an equivalent
&lt;em&gt;where&lt;/em&gt; clause before the projection (in which case you can drop the
projection).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Count&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Without a predicate &lt;code&gt;Count&lt;/code&gt; just returns the number of documents in
the collection.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    select c)
    .Count();
// or
var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Count();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Count (with predicate)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;With a predicate &lt;code&gt;Count&lt;/code&gt; returns the number of documents that match
the predicate.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    select c)
    .Count(c =&amp;gt; c.X == 1);
// or
var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Count(c =&amp;gt; c.X == 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the predicate can be provided either by a &lt;em&gt;where&lt;/em&gt; clause
or as an argument to &lt;code&gt;Count&lt;/code&gt;, so the following are equivalent to the
previous query.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.X == 1
    select c)
    .Count();
// or
var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.X == 1)
    .Count();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Count&lt;/code&gt; with a predicate is not supported after a projection (at
least not yet). So the following is not valid:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Select(c =&amp;gt; c.X)
    .Count(x =&amp;gt; x == 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can usually rewrite such a query by putting an equivalent
&lt;em&gt;where&lt;/em&gt; clause before the projection (in which case you can drop the
projection).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Distinct&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Distinct&lt;/code&gt; returns the unique values of a field or property of the
documents in the collection. You use a projection to identify the
field or property whose distinct values you want.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    select c.X)
    .Distinct();
// or
var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Select(c =&amp;gt; c.X)
    .Distinct();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The projection must select a particular field or property of the
document. If the value of that field or property is represented in
MongoDB as an array you can also use array indexing to select an
item from the array.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    select c.A[i])
    .Distinct();
// or
var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Select(c =&amp;gt; c.A[i])
    .Distinct();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;ElementAt&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ElementAt&lt;/code&gt; returns a particular document from a result set. Often
you will combine this with a sort order.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.X &amp;gt; 0
    orderby c.X
    select c)
    .ElementAt(index);
// or
var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.X &amp;gt; 0)
    .OrderBy(c =&amp;gt; c.X)
    .ElementAt(index);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the result set has fewer documents than index &lt;code&gt;ElementAt&lt;/code&gt; throws
an exception.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;ElementAtOrDefault&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ElementAtOrDefault&lt;/code&gt; is just like &lt;code&gt;ElementAt&lt;/code&gt; except that if there
are fewer documents than index it returns null instead of throwing
an exception.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;First&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;First&lt;/code&gt; returns the first document from a result set. Often you will
combine this with a sort order.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.X &amp;gt; 0
    orderby c.X
    select c)
    .First();
// or
var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.X &amp;gt; 0)
    .OrderBy(c =&amp;gt; c.X)
    .First();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the result set has no documents &lt;code&gt;First&lt;/code&gt; throws an exception.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;First (with predicate)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This overload of &lt;code&gt;First&lt;/code&gt; allows you to provide a predicate as an
argument to &lt;code&gt;First&lt;/code&gt;. This is an alternative to using a &lt;em&gt;where&lt;/em&gt;
clause.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    orderby c.X
    select c)
    .First(c =&amp;gt; c.X &amp;gt; 0);
// or
var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .OrderBy(c =&amp;gt; c.X)
    .First(c =&amp;gt; c.X &amp;gt; 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;First&lt;/code&gt; with a predicate is not supported after a projection (at
least not yet). So the following is not valid:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .OrderBy(c =&amp;gt; c.X)
    .Select(c =&amp;gt; c.X)
    .First(x =&amp;gt; x &amp;gt; 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can usually rewrite such a query by putting an equivalent
&lt;em&gt;where&lt;/em&gt; clause before the projection.&lt;/p&gt;

&lt;p&gt;If the result set has no documents &lt;code&gt;First&lt;/code&gt; with a predicate throws
an exception.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;FirstOrDefault&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;FirstOrDefault&lt;/code&gt; is just like &lt;code&gt;First&lt;/code&gt; except that if there are no
matching documents it returns &lt;code&gt;null&lt;/code&gt; instead of throwing an
exception.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;FirstOrDefault (with predicate)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;FirstOrDefault&lt;/code&gt; with a predicate is just like &lt;code&gt;First&lt;/code&gt; with a
predicate except that if there are no matching documents it returns
&lt;code&gt;null&lt;/code&gt; instead of throwing an exception.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Last&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Last&lt;/code&gt; returns the last document from a result set. Often you will
combine this with a sort order.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.X &amp;gt; 0
    orderby c.X
    select c)
    .Last();
// or
var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.X &amp;gt; 0)
    .OrderBy(c =&amp;gt; c.X)
    .Last();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the result set has no documents &lt;code&gt;Last&lt;/code&gt; throws an exception.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Last (with predicate)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This overload of &lt;code&gt;Last&lt;/code&gt; allows you to provide a predicate as an
argument to &lt;code&gt;Last&lt;/code&gt;. This is an alternative to using a &lt;em&gt;where&lt;/em&gt;
clause.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    orderby c.X
    select c)
    .Last(c =&amp;gt; c.X &amp;gt; 0);
// or
var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .OrderBy(c =&amp;gt; c.X)
    .Last(c =&amp;gt; c.X &amp;gt; 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Last&lt;/code&gt; with a predicate is not supported after a projection (at
least not yet). So the following is not valid:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .OrderBy(c =&amp;gt; c.X)
    .Select(c =&amp;gt; c.X)
    .Last(x =&amp;gt; x &amp;gt; 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can usually rewrite such a query by putting an equivalent
&lt;em&gt;where&lt;/em&gt; clause before the projection.&lt;/p&gt;

&lt;p&gt;If the result set has no documents &lt;code&gt;Last&lt;/code&gt; throws an exception.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;LastOrDefault&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LastOrDefault&lt;/code&gt; is just like &lt;code&gt;Last&lt;/code&gt; except that if there are no
matching documents it returns &lt;code&gt;null&lt;/code&gt; instead of throwing an
exception.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;LastOrDefault (with predicate)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LastOrDefault&lt;/code&gt; with a predicate is just like &lt;code&gt;Last&lt;/code&gt; with a
predicate except that if there are no matching documents it returns
&lt;code&gt;null&lt;/code&gt; instead of throwing an exception.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;LongCount&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LongCount&lt;/code&gt; is just like &lt;code&gt;Count&lt;/code&gt; except that the return value is a
64-bit integer instead of a 32-bit integer.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;LongCount (with predicate)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LongCount&lt;/code&gt; with a predicate is just like &lt;code&gt;Count&lt;/code&gt; with a predicate
except that the return value is a 64-bit integer instead of a 32-bit
integer.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Max&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Max&lt;/code&gt; returns the maximum value of a field or property of the
documents in the collection. You use a projection to identify the
field or property whose maximum value you want.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    select c.X)
    .Max();
// or
var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Select(c =&amp;gt; c.X)
    .Max();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The projection must select a particular field or property of the
document. If the value of that field or property is represented in
MongoDB as an array you can also use array indexing to select an
item from the array.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    select c.A[i])
    .Max();
// or
var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Select(c =&amp;gt; c.A[i])
    .Max();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Max (with selector)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This overload of &lt;code&gt;Max&lt;/code&gt; lets you select the field or property whose
maximum value you want as an argument to &lt;code&gt;Max&lt;/code&gt; instead of to
&lt;code&gt;Select&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    select c)
    .Max(c =&amp;gt; c.X);
// or
var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Max(c =&amp;gt; c.X);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Min&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Min&lt;/code&gt; returns the minimum value of a field or property of the
documents in the collection. You use a projection to identify the
field or property whose minimum value you want.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    select c.X)
    .Min();
// or
var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Select(c =&amp;gt; c.X)
    .Min();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The projection must select a particular field or property of the
document. If the value of that field or property is represented in
MongoDB as an array you can also use array indexing to select an
item from the array.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    select c.A[i])
    .Min();
// or
var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Select(c =&amp;gt; c.A[i])
    .Min();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Min (with selector)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This overload of &lt;code&gt;Min&lt;/code&gt; lets you select the field or property whose
minimum value you want as an argument to &lt;code&gt;Min&lt;/code&gt; instead of to
&lt;code&gt;Select&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    select c)
    .Min(c =&amp;gt; c.X);
// or
var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Min(c =&amp;gt; c.X);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;OfType&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The OfType operator will insert a discriminator into the query in
order to be more specific about choosing the correct documents.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;().OfType&amp;lt;D&amp;gt;()
    select c)
// or
var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .OfType&amp;lt;D&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;OrderBy&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;OrderBy&lt;/code&gt; is used to specify an ascending sort order for the result
set.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    orderby c.X
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .OrderBy(c =&amp;gt; c.X);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;OrderByDescending&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;OrderByDescending&lt;/code&gt; is used to specify a descending sort order for
the result set.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    orderby c.X descending
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .OrderByDescending(c =&amp;gt; c.X);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Select&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Select&lt;/code&gt; is used to project a new result type from the matching
documents. A projection must typically be the last operation (with a
few exceptions like &lt;code&gt;Distinct&lt;/code&gt;, &lt;code&gt;Max&lt;/code&gt; and &lt;code&gt;Min&lt;/code&gt;).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;warning&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Select&lt;/code&gt; does not result in fewer fields being returned from the
server. The entire document is pulled back and passed to the
native &lt;code&gt;Select&lt;/code&gt; method. Therefore, the projection is performed
client side.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    select new { c.X, c.Y };
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Select(c =&amp;gt; new { c.X, c.Y });
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Single&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Single&lt;/code&gt; returns the first and only document from a result set.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.X &amp;gt; 0
    orderby c.X
    select c)
    .Single();
// or
var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.X &amp;gt; 0)
    .OrderBy(c =&amp;gt; c.X)
    .Single();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the result set has no documents or multiple documents &lt;code&gt;Single&lt;/code&gt;
throws an exception.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Single (with predicate)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This overload of &lt;code&gt;Single&lt;/code&gt; allows you to provide a predicate as an
argument to &lt;code&gt;Single&lt;/code&gt; . This is an alternative to using a &lt;em&gt;where&lt;/em&gt;
clause.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    orderby c.X
    select c)
    .Single(c =&amp;gt; c.X &amp;gt; 0);
// or
var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .OrderBy(c =&amp;gt; c.X)
    .Single(c =&amp;gt; c.X &amp;gt; 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Single&lt;/code&gt; with a predicate is not supported after a projection (at
least not yet). So the following is not valid:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var result =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .OrderBy(c =&amp;gt; c.X)
    .Select(c =&amp;gt; c.X)
    .Single(x =&amp;gt; x &amp;gt; 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can usually rewrite such a query by putting an equivalent
&lt;em&gt;where&lt;/em&gt; clause before the projection.&lt;/p&gt;

&lt;p&gt;If the result set has no documents or multiple documents &lt;code&gt;Single&lt;/code&gt;
throws an exception.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;SingleOrDefault&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SingleOrDefault&lt;/code&gt; is just like &lt;code&gt;Single&lt;/code&gt; except that if there are no
matching documents it returns &lt;code&gt;null&lt;/code&gt; instead of throwing an
exception.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;SingleOrDefault (with predicate)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SingleOrDefault&lt;/code&gt; with a predicate is just like &lt;code&gt;Single&lt;/code&gt; with a
predicate except that if there are no matching documents it returns
&lt;code&gt;null&lt;/code&gt; instead of throwing an exception.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Skip&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Use &lt;code&gt;Skip&lt;/code&gt; to specify how many documents to skip from the beginning
of the result set. Often you will combine &lt;code&gt;Skip&lt;/code&gt; with a sort order.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    orderby c.X
    select c)
    .Skip(100);
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .OrderBy(c =&amp;gt; c.X)
    .Skip(100);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Take&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Use &lt;code&gt;Take&lt;/code&gt; to specify how many documents to return from the server.
When combining &lt;code&gt;Take&lt;/code&gt; with &lt;code&gt;Skip&lt;/code&gt; often you will also specify a sort
order.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    orderby c.X
    select c)
    .Skip(100)
    .Take(100);
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .OrderBy(c =&amp;gt; c.X)
    .Skip(100)
    .Take(100);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;ThenBy&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ThenBy&lt;/code&gt; is used to specify an additional ascending sort order for
the result set.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    orderby c.X, c.Y
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .OrderBy(c =&amp;gt; c.X)
    .ThenBy(c =&amp;gt; c.Y);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;ThenByDescending&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ThenByDescending&lt;/code&gt; is used to specify an additional descending sort
order for the result set.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    orderby c.X, c.Y descending
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .OrderBy(c =&amp;gt; c.X)
    .ThenByDescending(c =&amp;gt; c.Y);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Where&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;where&lt;/em&gt; clause is used to specify which documents the query should
return. A &lt;em&gt;where&lt;/em&gt; clause is a C# expression that maps the query
document type to a boolean value. If the expression returns true the
document &amp;ldquo;matches&amp;rdquo; the query and is included in the result set.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.X &amp;gt; 0
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.X &amp;gt; 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sometimes a predicate can be supplied in other places besides a
&lt;em&gt;where&lt;/em&gt; clause, and it is also possible to have multiple &lt;em&gt;where&lt;/em&gt;
clauses. When multiple predicates are involved they are combined
into a single composite predicate by combining the individual
predicates with the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator.&lt;/p&gt;

&lt;p&gt;For example, the following queries are equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.X &amp;gt; 0
    where c.Y &amp;gt; 0)
    .First(c.Z &amp;gt; 0);
// or
var query =
    (from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.X &amp;gt; 0 &amp;amp;&amp;amp; c.Y &amp;gt; 0 &amp;amp;&amp;amp; c.Z &amp;gt; 0)
    .First();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;supported-where-clauses&#34;&gt;Supported where clauses&lt;/h2&gt;

&lt;p&gt;This section documents the supported &lt;code&gt;where&lt;/code&gt; clauses.&lt;/p&gt;

&lt;p&gt;As mentioned earlier, not all C# expressions are supported as a &lt;em&gt;where&lt;/em&gt;
clause. You can use this documentation as a guide to what is supported,
or you can just try an expression and see if it works (a runtime
exception is thrown if the &lt;em&gt;where&lt;/em&gt; clause is not supported).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Where&lt;/em&gt; clauses are typically introduced using the &lt;code&gt;Where&lt;/code&gt; query
operator, but the same expressions are supported wherever a predicate is
called for. In some cases multiple &lt;em&gt;where&lt;/em&gt; clauses and predicates will
be combined, in which case they are combined with the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The 1.4 version of the C# driver requires that all &lt;em&gt;where&lt;/em&gt; clauses
that compare a field or property against a value have the constant on
the right hand side. This restriction will be lifted in the next
release.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; (&lt;strong&gt;And&lt;/strong&gt; operator)&lt;/p&gt;

&lt;p&gt;Sub-expressions can be combined with the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator to test
whether all of them are true.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.X &amp;gt; 0 &amp;amp;&amp;amp; c.Y &amp;gt; 0
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.X &amp;gt; 0 &amp;amp;&amp;amp; c.Y &amp;gt; 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated to the following MongoDB query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ X : { $gt : 0 }, Y : { $gt : 0 } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In some cases the &lt;code&gt;And&lt;/code&gt; query can&amp;rsquo;t be flattened as shown, and the
&lt;code&gt;$and&lt;/code&gt; operator will be used. The following example matches
documents where &lt;code&gt;X&lt;/code&gt; is both a multiple of &lt;code&gt;2&lt;/code&gt; and a multiple of &lt;code&gt;3&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where (c.X % 2 == 0) &amp;amp;&amp;amp; (c.X % 3 == 0)
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; (c.X % 2 == 0) &amp;amp;&amp;amp; (c.X % 3 == 0));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated to the following MongoDB query using &lt;code&gt;$and&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ $and : [{ X : { $mod : [2, 0] } }, { X : { $mod : [3, 0] } }] }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This method is used to test whether an array field or property
contains any items.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.A.Any()
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.A.Any());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;matches any document where &lt;code&gt;A&lt;/code&gt; has &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;more&lt;/code&gt; items.&lt;/p&gt;

&lt;p&gt;This is translated to the following MongoDB query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ A : { $ne : null, $not : { $size : 0 } } }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Any&lt;/code&gt; With Predicate&lt;/p&gt;

&lt;p&gt;This method is used to test entries in an array. It will generate an
\$elemMatch condition.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.A.Any(a =&amp;gt; a.B == 1)
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.A.Any(a =&amp;gt; a.B == 1));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated to the following MongoDB query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ A : { $elemMatch : { B : 1 } } }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This will only function when the elements of the enumerable are
serialized as a document. There is a server bug preventing this
from working against primitives.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Boolean constant&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This form is mostly for completeness. You will probably use it
rarely. It allows a boolean constant to be used to either match or
not match the document.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where true
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; true);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated to the following MongoDB query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ _id : { $exists : true } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which matches all documents since the &lt;code&gt;_id&lt;/code&gt; is a mandatory field.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Boolean field or property&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A boolean field or property of the document doesn&amp;rsquo;t have to be
compared to &lt;code&gt;true&lt;/code&gt;, it can just be mentioned in the &lt;em&gt;where&lt;/em&gt; clause
and there is an implied comparison to &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.B
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.B);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated to the following MongoDB query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ B : true }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Contains&lt;/code&gt; (Enumerable method)&lt;/p&gt;

&lt;p&gt;There are 2 uses for this method depending on context.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;To test whether an array (or array-like) field or property
contains a particular value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.A.Contains(123)
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.A.Contains(123));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated to the following MongoDB query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ A : 123 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This translation relies on the way array fields are treated by
the MongoDB query language.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;To test whether a field or property is contained in an array (or
array-like) field.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var local = new [] { 1, 2, 3 };


var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where local.Contains(c.A)
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; local.Contains(c.A));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated to the following MongoDB query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ A : { $in : [1, 2, 3] } }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Contains&lt;/code&gt; (string method)&lt;/p&gt;

&lt;p&gt;This method is used to test whether a string field or property of
the document contains a particular substring.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.S.Contains(&amp;quot;abc&amp;quot;)
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.S.Contains(&amp;quot;abc&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated to the following MongoDB query (using regular
expressions):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ S : /abc/ }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;ContainsAll&lt;/code&gt; (LINQ to MongoDB extension method)&lt;/p&gt;

&lt;p&gt;This method is used to test whether an array (or array-like) field
or property contains all of the provided values.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.A.ContainsAll(new[] { 1, 2, 3 })
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.A.ContainsAll(new[] { 1, 2, 3 }));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated to the following MongoDB query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ A : { $all : [1, 2, 3] } }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;ContainsAny&lt;/code&gt; (LINQ to MongoDB extension method)&lt;/p&gt;

&lt;p&gt;This method is used to test whether an array (or array-like) field
or property contains any of the provided values.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.A.ContainsAny(new[] { 1, 2, 3 })
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.A.ContainsAny(new[] { 1, 2, 3 }));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated to the following MongoDB query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ A : { $in : [1, 2, 3] } }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Count&lt;/code&gt; &lt;em&gt;method&lt;/em&gt; (array length)&lt;/p&gt;

&lt;p&gt;This method is used to test whether an enumerable field or property
has a certain count of items.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.L.Count() == 3
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.L.Count() == 3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated to the following MongoDB query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ L : { $size: 3 } }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Count&lt;/code&gt; &lt;em&gt;property&lt;/em&gt; (array length)&lt;/p&gt;

&lt;p&gt;This property is used to test whether a list (or list-like) field or
property has a certain count of items.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.L.Count == 3
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.L.Count == 3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated to the following MongoDB query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ L : { $size: 3 } }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;EndsWith&lt;/code&gt; (string method)&lt;/p&gt;

&lt;p&gt;This method is used to test whether a string field or property of
the document ends with a particular substring.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.S.EndsWith(&amp;quot;abc&amp;quot;)
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.S.EndsWith(&amp;quot;abc&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated to the following MongoDB query (using regular
expressions):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ S : /abc$/ }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;enum&lt;/code&gt; comparisons (&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;enum&lt;/code&gt; fields or properties can be compared to constants of the same
&lt;code&gt;enum&lt;/code&gt; type. The relative comparison are based on the value of the
underlying integer type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public enum E { None, A, B };


var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.E == E.A
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.E == E.A);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated to the following MongoDB query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ E : 1 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The LINQ implementation takes the representation of serialized
values into account, so if you have configured your class map to
store enums as string values instead of integer values the MongoDB
query would instead be:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ E : &amp;quot;A&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;GetType&lt;/code&gt; (Type method)&lt;/p&gt;

&lt;p&gt;This is exactly like the OfType method. It will generate a
discriminator &amp;ldquo;and&amp;rdquo;ed with the other predicates.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.GetType() == typeof(D)
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.GetType() == typeof(D));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated roughly to the following MongoDB query depending
on how your discriminators are created.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ _t : &amp;quot;D&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;In&lt;/code&gt; (LINQ to MongoDB extension method)&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;In&lt;/code&gt; method is used to test whether a field or property is equal
any of a set of provided values.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.X.In(new [] { 1, 2, 3 })
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c.X.In(new [] { 1, 2, 3 }));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated to the following MongoDB query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ X : { $in : [1, 2, 3] } }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Inject&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Inject&lt;/code&gt; is a pseudo-method that is used to inject a lower level
MongoDB query into a LINQ query. The following query looks for &lt;code&gt;X&lt;/code&gt;
values that are larger than 0 and are 64-bit integers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.X &amp;gt; 0 &amp;amp;&amp;amp; Query.Type(&amp;quot;X&amp;quot;, BsonType.Int64).Inject()
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.X &amp;gt; 0 &amp;amp;&amp;amp; Query.Type(&amp;quot;X&amp;quot;, BsonType.Int64).Inject());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated to the following MongoDB query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ X : { $gt : 0, $type : 18 } }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;is&lt;/code&gt; C# keyword&lt;/p&gt;

&lt;p&gt;This is exactly like the OfType method. It will generate a
discriminator &amp;ldquo;and&amp;rdquo;ed with the other predicates.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c is D &amp;amp;&amp;amp; ((D)c).B == 1
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c is D &amp;amp;&amp;amp; ((D)c).B == 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated to the something similar to the following,
depending on how your discriminators are setup.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ _t : &amp;quot;D&amp;quot;, B : 1 }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;IsMatch&lt;/code&gt; (regular expression method)&lt;/p&gt;

&lt;p&gt;This method is used to test whether a string field or property
matches a regular expression.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var regex = new Regex(&amp;quot;^abc&amp;quot;);
var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where regex.IsMatch(c.S)
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; regex.IsMatch(c.S));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated to the following MongoDB query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ S : /^abc/ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also use the static &lt;code&gt;IsMatch&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where Regex.IsMatch(c.S, &amp;quot;^abc&amp;quot;)
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; Regex.IsMatch(c.S, &amp;quot;^abc&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated to the following MongoDB query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ S : /^abc/ }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Length&lt;/code&gt; (array length)&lt;/p&gt;

&lt;p&gt;This method is used to test whether an array (or array-like) field
or property has a certain count of items.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.A.Length == 3
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.A.Length == 3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated to the following MongoDB query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ A : { $size: 3 } }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;%&lt;/code&gt; (&lt;strong&gt;Mod&lt;/strong&gt; operator)&lt;/p&gt;

&lt;p&gt;This operator is used to test the result of the mod operator against
a field or property of the document. The following query matches all
the documents where &lt;code&gt;X&lt;/code&gt; is odd.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.X % 2 == 1
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.X % 2 == 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated to the following MongoDB query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ X : { $mod : [2, 1] } }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;!&lt;/code&gt; (&lt;strong&gt;Not&lt;/strong&gt; operator)&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;!&lt;/code&gt; operator is used to reverse the sense of a test.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where !(c.X &amp;gt; 1)
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; !(c.X &amp;gt; 1));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated into the following MongoDB query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ X : { $not : { $gt : 1 } } }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;!(c.X &amp;gt; 1)&lt;/code&gt; is not equivalent to &lt;code&gt;(c.X &amp;lt;= 1)&lt;/code&gt; in cases where
&lt;code&gt;c.X&lt;/code&gt; is missing or does not have a numeric type.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Numeric comparisons (&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;Numeric fields or properties can be compared using any of the above
operators.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.X == 0 &amp;amp;&amp;amp; c.Y &amp;lt; 100
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.X == 0 &amp;amp;&amp;amp; c.Y &amp;lt; 100);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated into the following MongoDB query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ X : 0, Y : { $lt : 100 } }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;||&lt;/code&gt; (&lt;strong&gt;Or&lt;/strong&gt; operator)&lt;/p&gt;

&lt;p&gt;Sub-expressions can be combined with the &lt;code&gt;||&lt;/code&gt; operator to test
whether any of them is true.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.X &amp;gt; 0 || c.Y &amp;gt; 0
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.X &amp;gt; 0 || c.Y &amp;gt; 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated to the following MongoDB query:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ $or : [{ X : { $gt : 0 } }, { Y : { $gt : 0 } }] }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;StartsWith&lt;/code&gt; (string method)&lt;/p&gt;

&lt;p&gt;This method is used to test whether a string field or property of
the document starts with a particular substring.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.S.StartsWith(&amp;quot;abc&amp;quot;)
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.S.StartsWith(&amp;quot;abc&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is translated to the following MongoDB query (using regular
expressions):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ S : /^abc/ }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;ToLower&lt;/code&gt;, &lt;code&gt;ToLowerInvariant&lt;/code&gt;, &lt;code&gt;ToUpper&lt;/code&gt;, &lt;code&gt;ToUpperInvariant&lt;/code&gt; (string
method)&lt;/p&gt;

&lt;p&gt;These methods are used to test whether a string field or property of
the document matches a value in a case-insensitive manner.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query =
    from c in collection.AsQueryable&amp;lt;C&amp;gt;()
    where c.S.ToLower() == &amp;quot;abc&amp;quot;
    select c;
// or
var query =
    collection.AsQueryable&amp;lt;C&amp;gt;()
    .Where(c =&amp;gt; c.S.ToLower() == &amp;quot;abc&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;This is translated to the following MongoDB query (using regular
expressions):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode javascript&#34;&gt;{ S : /^abc$/i }
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Serialization Tutorial</title>
      <link>/mongo-csharp-driver/1.11/serialization/</link>
      <pubDate>Wed, 18 Mar 2015 16:56:14 +0000</pubDate>
      
      <guid>/mongo-csharp-driver/1.11/serialization/</guid>
      <description>

&lt;h1 id=&#34;serialization-tutorial&#34;&gt;Serialization Tutorial&lt;/h1&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;This section of the C# Driver Tutorial discusses serialization (and
deserialization) of instances of C# classes to and from BSON documents.
Serialization is the process of mapping an object to a BSON document
that can be saved in MongoDB, and deserialization is the reverse process
of reconstructing an object from a BSON document. For that reason the
serialization process is also often referred to as &amp;ldquo;Object Mapping.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Serialization is handled by the BSON Library. The BSON Library has an
extensible serialization architecture, so if you need to take control of
serialization you can. The BSON Library provides a default serializer
which should meet most of your needs, and you can supplement the default
serializer in various ways to handle your particular needs.&lt;/p&gt;

&lt;p&gt;The main way the default serializer handles serialization is through
&amp;ldquo;class maps&amp;rdquo;. A class map is a structure that defines the mapping
between a class and a BSON document. It contains a list of the fields
and properties of the class that participate in serialization and for
each one defines the required serialization parameters (e.g., the name
of the BSON element, representation options, etc&amp;hellip;).&lt;/p&gt;

&lt;p&gt;The default serializer also has built in support for many .NET data
types (primitive values, arrays, lists, dictionaries, etc&amp;hellip;) for which
class maps are not used.&lt;/p&gt;

&lt;p&gt;Before an instance of a class can be serialized a class map must exist.
You can either create this class map yourself or simply allow the class
map to be created automatically when first needed (called
&amp;ldquo;automapping&amp;rdquo;). You can exert some control over the automapping process
either by decorating your classes with serialization related attributes
or by using initialization code (attributes are very convenient to use
but for those who prefer to keep serialization details out of their
domain classes be assured that anything that can be done with attributes
can also be done without them).&lt;/p&gt;

&lt;h2 id=&#34;creating-a-class-map&#34;&gt;Creating a Class Map&lt;/h2&gt;

&lt;p&gt;To create a class map in your initialization code write:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which results in &lt;code&gt;MyClass&lt;/code&gt; being automapped and registered. In this case
you could just as well have allowed the class to be automapped by the
serializer (when first serialized or deserialized). The one case where
you must call &lt;code&gt;RegisterClassMap&lt;/code&gt; yourself (even without arguments) is
when you are using a polymorphic class hierarchy: in this case you must
register all the known subclasses to guarantee that the discriminators
get registered.&lt;/p&gt;

&lt;p&gt;If you want to control the creation of the class map you can provide
your own initialization code in the form of a lambda expression:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; {
    cm.MapProperty(c =&amp;gt; c.SomeProperty);
    cm.MapProperty(c =&amp;gt; c.AnotherProperty);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When your lambda expression is executed the &lt;code&gt;cm&lt;/code&gt; (short for class map)
parameter is passed an empty class map for you to fill in. In this
example two properties are added to the class map by calling the
&lt;code&gt;MapProperty&lt;/code&gt; method. The arguments to &lt;code&gt;MapProperty&lt;/code&gt; are themselves
lambda expressions which identify the property of the class. The
advantage of using a lambda expression instead of just a string
parameter with the name of the property is that &lt;code&gt;Intellisense&lt;/code&gt; and
compile time checking ensure that you can&amp;rsquo;t misspell the name of the
property.&lt;/p&gt;

&lt;p&gt;It is also possible to use automapping and then override some of the
results. We will see examples of that later on.&lt;/p&gt;

&lt;p&gt;Note that a class map must only be registered once (an exception will be
thrown if you try to register the same class map more than once).
Usually you call &lt;code&gt;RegisterClassMap&lt;/code&gt; from some code path that is known to
execute only once (the &lt;code&gt;Main&lt;/code&gt; method, the &lt;code&gt;Application_Start&lt;/code&gt; event
handler, etc&amp;hellip;). If you must call &lt;code&gt;RegisterClassMap&lt;/code&gt; from a code path
that executes more than once, you can use &lt;code&gt;IsClassMapRegistered&lt;/code&gt; to
check whether a class map has already been registered for a class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;if (!BsonClassMap.IsClassMapRegistered(typeof(MyClass))) {
   // register class map for MyClass
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;creator-maps&#34;&gt;Creator Maps&lt;/h3&gt;

&lt;p&gt;By default, classes must contain a zero-argument constructor that will
be used to instantiate an instance to hydrate. However, it is possible
to configure a constructor whose arguments are correlated with mapped
properties or fields. There are a couple of ways to do this.&lt;/p&gt;

&lt;p&gt;Using an expression, you can instruct the driver to use a creator map as
follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class Person
{
  public string FirstName { get; private set; }
  public string LastName { get; private set; }

  public Person(string firstName, string lastName)
  {
    FirstName = firstName;
    LastName = lastName;
  }
}

// snip...

BsonClassMap.RegisterClassMap&amp;lt;Person&amp;gt;(cm =&amp;gt;
{
    cm.AutoMap();
    cm.MapCreator(p =&amp;gt; new Person(p.FirstName, p.LastName));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Parsing the expression tree correlates the first constructor argument
with the &lt;code&gt;FirstName&lt;/code&gt; property and the second constructor argument with
the &lt;code&gt;LastName&lt;/code&gt; property. There are other, more complicated ways of
handling this which can be explored on your own should the need arise.&lt;/p&gt;

&lt;p&gt;Using attributes instead:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class Person
{
  public string FirstName { get; set; }
  public string LastName { get; set; }

  [BsonConstructor]
  public Person(string firstName, string lastName)
  {
    FirstName = firstName;
    LastName = lastName;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default, a convention runs on every CreatorMap with no mapped
arguments and attempts to correlate the names of the constructor
arguments with the names of mapped members. If your names differ in more
than just case, there are overloads of BsonConstructor which can be used
to explicity tell the driver which members to use.&lt;/p&gt;

&lt;p&gt;When more than 1 constructor is found, we will use the most parameters
fulfilled strategy to identify the best match. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class Person
{
  public string FirstName { get; set; }
  public string LastName { get; set; }
  public DateTime? BirthDate { get; set; }

  [BsonConstructor]
  public Person(string firstName, string lastName)
  {
    // snip...
  }

  [BsonConstructor]
  public Person(string firstName, string lastName, DateTime birthDate)
  {
    // snip...
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the document in the database has a BirthDate element, we will choose
to use the constructor with 3 parameters because it is more specific.&lt;/p&gt;

&lt;p&gt;In addition to the above code and attribute forms, mapping a creator can
be handled via conventions.&lt;/p&gt;

&lt;h2 id=&#34;conventions&#34;&gt;Conventions&lt;/h2&gt;

&lt;p&gt;When automapping a class there are a lot of decisions that need to be
made. For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Which fields or properties of the class should be serialized&lt;/li&gt;
&lt;li&gt;Which field or property of the class is the &amp;ldquo;Id&amp;rdquo;&lt;/li&gt;
&lt;li&gt;What element name should be used in the BSON document&lt;/li&gt;
&lt;li&gt;If the class is being used polymorphically what discriminator values
are used&lt;/li&gt;
&lt;li&gt;What should happen if a BSON document has elements we don&amp;rsquo;t
recognize&lt;/li&gt;
&lt;li&gt;Does the field or property have a default value&lt;/li&gt;
&lt;li&gt;Should the default value be serialized or ignored&lt;/li&gt;
&lt;li&gt;Should &lt;code&gt;null&lt;/code&gt; values be serialized or ignored&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Answers to these questions are represented by a set of &amp;ldquo;conventions&amp;rdquo;.
For each convention there is a default convention that is the most
likely one you will be using, but you can override individual
conventions (and even write your own) as necessary.&lt;/p&gt;

&lt;p&gt;If you want to use your own conventions that differ from the defaults
simply create an instance of &lt;code&gt;ConventionPack&lt;/code&gt; and add in the conventions
you want to use and then register that pack (in other words, tell the
default serializer when your special conventions should be used). For
example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var pack = new ConventionPack();
pack.Add(new CamelCaseElementNameConvention());

ConventionRegistry.Register(
   &amp;quot;My Custom Conventions&amp;quot;,
   pack,
   t =&amp;gt; t.FullName.StartsWith(&amp;quot;MyNamespace.&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The third parameter is a filter function that defines when this
convention pack should be used. In this case we are saying that any
classes whose full names begin with &lt;code&gt;&amp;quot;MyNamespace.&amp;quot;&lt;/code&gt; should use
&lt;code&gt;myConventions&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In addition to pre-packaged conventions, it is possible to write your
own. There are 4 classes of conventions which can be created and
registered. These 4 classes of conventions correspond with the 4 stages
in which they will be run.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Class Stage&lt;/code&gt;: &lt;code&gt;IClassMapConvention&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;:   Run against the class map.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Member Stage&lt;/code&gt;: &lt;code&gt;IMemberMapConvention&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;:   Run against each member map discovered during the
    &lt;code&gt;IClassMapConvention&lt;/code&gt; stage.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Creator Stage&lt;/code&gt;: &lt;code&gt;ICreatorMapConvention&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;:   Run against each CreatorMap discovered during the
    &lt;code&gt;IClassMapConvention&lt;/code&gt; stage.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;Post Processing Stage&lt;/code&gt;: &lt;code&gt;IPostProcessingConvention&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;:   Run against the class map.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Conventions get run in the order they were registered in each stage. The
default set of conventions is registered first. This allows any user
registered conventions to override the values applied by the default
conventions. Hence, it is possible that certain values may get applied
and overwritten. It is up to the user to ensure that the order is
correct.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If a custom implementation of an &lt;code&gt;IPostProcessingConvention&lt;/code&gt; is
registered before a customer implementation of an
&lt;code&gt;IClassMapConvention&lt;/code&gt;, the &lt;code&gt;IClassMapConvention&lt;/code&gt; will be run first
because the &lt;code&gt;Class Stage&lt;/code&gt; is before the &lt;code&gt;Post Processing Stage&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;field-or-property-level-serialization-options&#34;&gt;Field or Property Level Serialization Options&lt;/h2&gt;

&lt;p&gt;There are many ways you can control serialization. The previous section
discussed conventions, which are a convenient way to control
serialization decisions for many classes at once. You can also control
serialization at the individual class or field or property level using
code to configure the class and member maps or using attributes to
decorate the class and members. For each aspect of serialization you can
control, we will be showing both ways.&lt;/p&gt;

&lt;h3 id=&#34;opt-in&#34;&gt;Opt-In&lt;/h3&gt;

&lt;p&gt;A majority of classes will have their properties mapped automatically.
There are some circumstances where this does not happen. For instance,
if your property is read-only, it will not get included in the
automapping of a class by default. In order to include the member, you
can use the &lt;code&gt;BsonElementAttribute&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class MyClass {
    private readonly string _someProperty;

    [BsonElement]
    public string SomeProperty
    {
        get { return _someProperty; }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The same result can be achieved without using attributes with the
following initialization code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; {
    cm.MapProperty(c =&amp;gt; c.SomeProperty);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;When a readonly property is serialized, it value is persisted to the
database, but never read back out. This is useful for storing
&amp;ldquo;computed&amp;rdquo; properties&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;element-name&#34;&gt;Element name&lt;/h3&gt;

&lt;p&gt;To specify an element name using attributes, write:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class MyClass {
    [BsonElement(&amp;quot;sp&amp;quot;)]
    public string SomeProperty { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The same result can be achieved without using attributes with the
following initialization code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; {
    cm.AutoMap();
    cm.GetMemberMap(c =&amp;gt; c.SomeProperty).SetElementName(&amp;quot;sp&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that we are first automapping the class and then overriding one
particular piece of the class map. If you didn&amp;rsquo;t call &lt;code&gt;AutoMap&lt;/code&gt; first
then GetMemberMap would throw an exception because there would be no
member maps.&lt;/p&gt;

&lt;h3 id=&#34;element-order&#34;&gt;Element Order&lt;/h3&gt;

&lt;p&gt;If you want precise control over the order of the elements in the BSON
document you can use the &lt;code&gt;Order&lt;/code&gt; named parameter to the &lt;code&gt;BsonElement&lt;/code&gt;
attribute:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class MyClass {
    [BsonElement(&amp;quot;sp&amp;quot;, Order = 1)]
    public string SomeProperty { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or using initialization code instead of attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; {
    cm.AutoMap();
    cm.GetMemberMap(c =&amp;gt; c.SomeProperty).SetElementName(&amp;quot;sp&amp;quot;).SetOrder(1);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Any fields or properties that do not have an explicit &lt;code&gt;Order&lt;/code&gt; will occur
after those that do have an &lt;code&gt;Order&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;identifying-the-id-field-or-property&#34;&gt;Identifying the Id Field or Property&lt;/h3&gt;

&lt;p&gt;To identify which field or property of a class is the Id you can write:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class MyClass {
    [BsonId]
    public string SomeProperty { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or using initialization code instead of attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; {
    cm.AutoMap();
    cm.SetIdMember(cm.GetMemberMap(c =&amp;gt; c.SomeProperty));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When not using &lt;code&gt;AutoMap&lt;/code&gt;, you can also map a field or property and
identify it as the Id in one step as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; {
    cm.MapIdProperty(c =&amp;gt; c.SomeProperty);
    // mappings for other fields and properties
});
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The default conventions will discover a public property or field with
the name &amp;ldquo;Id&amp;rdquo;, &amp;ldquo;id&amp;rdquo;, or &amp;ldquo;_id&amp;rdquo;. It is generally unnecessary to
decorate this field with an attribute or map it explicitly.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;selecting-an-idgenerator-to-use-for-an-id-field-or-property&#34;&gt;Selecting an IdGenerator to Use for an Id Field or Property&lt;/h3&gt;

&lt;p&gt;When you Insert a document the C# driver checks to see if the &lt;code&gt;Id&lt;/code&gt;
member has been assigned a value, and if not, generates a new unique
value for it. Since the &lt;code&gt;Id&lt;/code&gt; member can be of any type, the driver
requires the help of a matching &lt;code&gt;IdGenerator&lt;/code&gt; to check whether the &lt;code&gt;Id&lt;/code&gt;
has a value assigned to it and to generate a new value if necessary. The
driver has the following &lt;code&gt;IdGenerators&lt;/code&gt; built-in:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BsonObjectIdGenerator&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CombGuidGenerator&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GuidGenerator&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NullIdChecker&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ObjectIdGenerator&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StringObjectIdGenerator&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ZeroIdChecker&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Some of these &lt;code&gt;IdGenerators&lt;/code&gt; are used automatically for commonly used
&lt;code&gt;Id&lt;/code&gt; types:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BsonObjectIdGenerator&lt;/code&gt; is used for &lt;code&gt;BsonObjectId&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GuidGenerator&lt;/code&gt; is used for &lt;code&gt;Guid&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ObjectIdGenerator&lt;/code&gt; is used for &lt;code&gt;ObjectId&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StringObjectIdGenerator&lt;/code&gt; is used for strings represented externally
as &lt;code&gt;ObjectId&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To select an &lt;code&gt;IdGenerator&lt;/code&gt; to use for your &lt;code&gt;Id&lt;/code&gt; field or property write:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class MyClass {
    [BsonId(IdGenerator = typeof(CombGuidGenerator))]
    public Guid Id { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or using initialization code instead of attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; {
    cm.AutoMap();
    cm.IdMemberMap.SetIdGenerator(CombGuidGenerator.Instance);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You could also say that you want to use the &lt;code&gt;CombGuidGenerator&lt;/code&gt; for all
&lt;code&gt;Guids&lt;/code&gt;. In this case you would write:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonSerializer.RegisterIdGenerator(
    typeof(Guid),
    CombGuidGenerator.Instance
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;NullIdChecker&lt;/code&gt; and &lt;code&gt;ZeroIdChecker&amp;lt;T&amp;gt;&lt;/code&gt; IdGenerators can be used when
you don&amp;rsquo;t have an &lt;code&gt;IdGenerator&lt;/code&gt; for an &lt;code&gt;Id&lt;/code&gt; type but you want to enforce
that the &lt;code&gt;Id&lt;/code&gt; is not null or zero. These pseudo-IdGenerators throw an
exception if their &lt;code&gt;GenerateId&lt;/code&gt; method is called. You can select it for
an individual member just like a &lt;code&gt;CombGuidGenerator&lt;/code&gt; was selected in the
previous example, or you can turn on one or both of these &lt;code&gt;IdGenerators&lt;/code&gt;
for all types as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonSerializer.UseNullIdChecker = true; // used for reference types
BsonSerializer.UseZeroIdChecker = true; // used for value types
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In version 1.0 of the C# Driver &lt;code&gt;NullIdChecker&lt;/code&gt; and
&lt;code&gt;ZeroIdChecker&amp;lt;T&amp;gt;&lt;/code&gt; were always used, but it was decided that their use
should be optional, since null and zero are valid values for an &lt;code&gt;Id&lt;/code&gt;
as far as the server is concerned, so they should only be considered
an error if the developer has specifically said they should be.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;ignoring-a-field-or-property&#34;&gt;Ignoring a Field or Property&lt;/h3&gt;

&lt;p&gt;When constructing a class map manually you can ignore a field or
property simply by not adding it to the class map. When using &lt;code&gt;AutoMap&lt;/code&gt;
you need a way to specify that a field or property should be ignored. To
do so using attributes write:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class MyClass {
    [BsonIgnore]
    public string SomeProperty { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or using initialization code instead of attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; {
    cm.AutoMap();
    cm.UnmapProperty(c =&amp;gt; c.SomeProperty);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case &lt;code&gt;AutoMap&lt;/code&gt; will have initially added the property to the
class map automatically but then &lt;code&gt;UnmapProperty&lt;/code&gt; will remove it.&lt;/p&gt;

&lt;h3 id=&#34;ignoring-null-values&#34;&gt;Ignoring &lt;code&gt;null&lt;/code&gt; Values&lt;/h3&gt;

&lt;p&gt;By default &lt;code&gt;null&lt;/code&gt; values are serialized to the BSON document as a BSON
&lt;code&gt;Null&lt;/code&gt;. An alternative is to serialize nothing to the BSON document when
the field or property has a &lt;code&gt;null&lt;/code&gt; value. To specify this using
attributes write:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class MyClass {
    [BsonIgnoreIfNull]
    public string SomeProperty { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or using initialization code instead of attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; {
    cm.AutoMap();
    cm.GetMemberMap(c =&amp;gt; c.SomeProperty).SetIgnoreIfNull(true);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;default-values&#34;&gt;Default Values&lt;/h3&gt;

&lt;p&gt;You can specify a default value for a field or property as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class MyClass {
    [BsonDefaultValue(&amp;quot;abc&amp;quot;)]
    public string SomeProperty { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or using initialization code instead of attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; {
    cm.AutoMap();
    cm.GetMemberMap(c =&amp;gt; c.SomeProperty).SetDefaultValue(&amp;quot;abc&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also control whether default values are serialized or not (the
default is yes). To not serialize default values using attributes write:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class MyClass {
    [BsonDefaultValue(&amp;quot;abc&amp;quot;)]
    [BsonIgnoreIfDefault]
    public string SomeProperty { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or using initialization code instead of attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; {
    cm.AutoMap();
    cm.GetMemberMap(c =&amp;gt; c.SomeProperty)
        .SetDefaultValue(&amp;quot;abc&amp;quot;)
        .SetIgnoreIfDefault(true);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ignoring-a-member-based-on-a-shouldserializexyz-method&#34;&gt;Ignoring a Member Based on a &lt;em&gt;ShouldSerializeXyz&lt;/em&gt; Method&lt;/h3&gt;

&lt;p&gt;Sometimes the decision whether to serialize a member or not is more
complicated than just whether the value is &lt;code&gt;null&lt;/code&gt; or equal to the
default value. You can write a method that determines whether a value
should be serialized. Usually the method for member &lt;em&gt;Xyz&lt;/em&gt; is named
&lt;em&gt;ShouldSerializeXyz&lt;/em&gt;. If you follow this naming convention then
&lt;code&gt;AutoMap&lt;/code&gt; will automatically detect the method and use it. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class Employee {
    public ObjectId Id { get; set; }
    [BsonDateTimeOptions(DateOnly = true)]
    public DateTime DateOfBirth { get; set; }

    public bool ShouldSerializeDateOfBirth() {
        return DateOfBirth &amp;gt; new DateTime(1900, 1, 1);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or using initialization code instead of naming conventions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;Employee&amp;gt;(cm =&amp;gt; {
    cm.AutoMap();
    cm.GetMemberMap(c =&amp;gt; c.DateOfBirth).SetShouldSerializeMethod(
        obj =&amp;gt; ((Employee) obj).DateOfBirth &amp;gt; new DateTime(1900, 1, 1)
    );
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;identifying-required-fields&#34;&gt;Identifying Required Fields&lt;/h3&gt;

&lt;p&gt;Normally, the deserializer doesn&amp;rsquo;t care if the document being
deserialized doesn&amp;rsquo;t have a matching element for every field or property
of the class. The members that don&amp;rsquo;t have a matching element simply get
assigned their default value.&lt;/p&gt;

&lt;p&gt;If you want to make an element in the document be required, you can mark
an individual field or property like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class MyClass {
    public ObjectId Id { get; set; }
    [BsonRequired]
    public string X { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or using initialization code instead attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; {
    cm.AutoMap();
    cm.GetMemberMap(c =&amp;gt; c.X).SetIsRequired(true);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;warning&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This will throw an exception during deserialization. The required
state of a member map does not apply to serialization.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;specifying-the-serializer&#34;&gt;Specifying the Serializer&lt;/h3&gt;

&lt;p&gt;There are times when a specific serializer needs to be used rather than
letting the Bson library choose. This can be done in a couple of ways:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class MyClass {
    public ObjectId Id { get; set; }
    [BsonSerializer(typeof(MyCustomStringSerializer))]
    public string X { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or using initialization code instead attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; {
    cm.AutoMap();
    cm.GetMemberMap(c =&amp;gt; c.X).SetSerializer(new MyCustomStringSerializer());
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;serialization-options&#34;&gt;Serialization Options&lt;/h3&gt;

&lt;p&gt;Serialization of some classes can be more finely controlled using
serialization options (which are represented using classes that
implement the &lt;code&gt;IBsonSerializationOptions&lt;/code&gt; interface). Whether a class
uses serialization options or not, and which ones, depends on the
particular class involved. The following sections describe the available
serialization option classes and the classes that use them.&lt;/p&gt;

&lt;h4 id=&#34;datetimeserializationoptions&#34;&gt;DateTimeSerializationOptions&lt;/h4&gt;

&lt;p&gt;These serialization options control how a &lt;code&gt;DateTime&lt;/code&gt; is serialized. For
example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class MyClass {
    [BsonDateTimeOptions(DateOnly = true)]
    public DateTime DateOfBirth { get; set; }
    [BsonDateTimeOptions(Kind = DateTimeKind.Local)]
    public DateTime AppointmentTime { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we are specifying that the &lt;code&gt;DateOfBirth&lt;/code&gt; value holds a date only
(so the &lt;code&gt;TimeOfDay&lt;/code&gt; component must be zero). Additionally, because this
is a date only, no timezone conversions at all will be performed. The
&lt;code&gt;AppointmentTime&lt;/code&gt; value is in local time and will be converted to UTC
when it is serialized and converted back to local time when it is
deserialized.&lt;/p&gt;

&lt;p&gt;You can specify the same options using initialization code instead of
attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; {
    cm.AutoMap();
    cm.GetMemberMap(c =&amp;gt; c.DateOfBirth)
        .SetSerializationOptions(
            new DateTimeSerializationOptions { DateOnly = true });
    cm.GetMemberMap(c =&amp;gt; c.AppointmentTime)
        .SetSerializationOptions(
            new DateTimeSerializationOptions { Kind = DateTimeKind.Local });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;DateTimeSerializationOptions&lt;/code&gt; are supported by the serializers for the
following classes: &lt;code&gt;BsonDateTime&lt;/code&gt; and &lt;code&gt;DateTime&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;dictionaryserializationoptions&#34;&gt;DictionarySerializationOptions&lt;/h4&gt;

&lt;p&gt;When serializing dictionaries there are several alternative ways that
the contents of the dictionary can be represented. The different ways
are represented by the &lt;code&gt;DictionaryRepresentation&lt;/code&gt; enumeration:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public enum DictionaryRepresentation {
    Dynamic,
    Document,
    ArrayOfArrays,
    ArrayOfDocuments
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A dictionary represented as a &lt;code&gt;Document&lt;/code&gt; will be stored as a
&lt;code&gt;BsonDocument&lt;/code&gt;, and each entry in the dictionary will be represented by
a &lt;code&gt;BsonElement&lt;/code&gt; with the name equal to the key of the dictionary entry
and the value equal to the value of the dictionary entry. This
representation can only be used when all the keys in a dictionary are
strings that are valid element names.&lt;/p&gt;

&lt;p&gt;A dictionary represented as an &lt;code&gt;ArrayOfArrays&lt;/code&gt; will be stored as a
&lt;code&gt;BsonArray&lt;/code&gt; of key/value pairs, where each key/value pair is stored as a
nested two-element &lt;code&gt;BsonArray&lt;/code&gt; where the two elements are the key and
the value of the dictionary entry. This representation can be used even
when the keys of the dictionary are not strings. This representation is
very general and compact, and is the default representation when
&lt;code&gt;Document&lt;/code&gt; does not apply. One problem with this representation is that
it is difficult to write queries against it, which motivated the
introduction in the 1.2 version of the driver of the &lt;code&gt;ArrayOfDocuments&lt;/code&gt;
representation.&lt;/p&gt;

&lt;p&gt;A dictionary represented as an &lt;code&gt;ArrayOfDocuments&lt;/code&gt; will be stored as a
&lt;code&gt;BsonArray&lt;/code&gt; of key/value pairs, where each key/value pair is stored as a
nested two-element &lt;code&gt;BsonDocument&lt;/code&gt; of the form &lt;code&gt;{ k : key, v : value }&lt;/code&gt;.
This representation is just as general as the &lt;code&gt;ArrayOfArrays&lt;/code&gt;
representation, but because the keys and values are tagged with element
names it is much easier to write queries against it. For backward
compatibility reasons this is not the default representation.&lt;/p&gt;

&lt;p&gt;If the &lt;code&gt;Dynamic&lt;/code&gt; representation is specified, the dictionary key values
are inspected before serialization, and if all the keys are strings
which are also valid element names, then the &lt;code&gt;Document&lt;/code&gt; representation
will be used, otherwise the &lt;code&gt;ArrayOfArrays&lt;/code&gt; representation will be used.&lt;/p&gt;

&lt;p&gt;If no other representation for a dictionary is specified, then &lt;code&gt;Dynamic&lt;/code&gt;
is assumed.&lt;/p&gt;

&lt;p&gt;You can specify a &lt;code&gt;DictionarySerializationOption&lt;/code&gt; as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class C {
    public ObjectId Id;
    [BsonDictionaryOptions(DictionaryRepresentation.ArrayOfDocuments)]
    public Dictionary&amp;lt;string, int&amp;gt; Values;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or using initialization code instead of attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;C&amp;gt;(cm =&amp;gt; {
    cm.AutoMap();
    cm.GetMemberMap(c =&amp;gt; c.Values)
        .SetSerializationOptions(DictionarySerializationOptions.ArrayOfDocuments);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;DictionarySerializationOptions&lt;/code&gt; are supported by the serializers for
the following classes: the generic classes and interfaces &lt;code&gt;Dictionary&lt;/code&gt;,
&lt;code&gt;IDictionary&lt;/code&gt;, &lt;code&gt;SortedDictionary&lt;/code&gt; and &lt;code&gt;SortedList&lt;/code&gt;, and the non-generic
classes and interfaces &lt;code&gt;Hashtable&lt;/code&gt;, &lt;code&gt;IDictionary&lt;/code&gt;, &lt;code&gt;ListDictionary&lt;/code&gt;,
&lt;code&gt;OrderedDictionary&lt;/code&gt; and &lt;code&gt;SortedList&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;representationserializationoptions&#34;&gt;RepresentationSerializationOptions&lt;/h4&gt;

&lt;p&gt;For some .NET primitive types you can control what BSON type you want
used to represent the value in the BSON document. For example, you can
specify whether a char value should be represented as a BSON Int32 or as
a one-character BSON String:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class MyClass {
    [BsonRepresentation(BsonType.Int32)]
    public char RepresentAsInt32 { get; set; }
    [BsonRepresentation(BsonType.String)]
    public char RepresentAsString { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or using initialization code instead of attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; {
    cm.AutoMap();
    cm.GetMemberMap(c =&amp;gt; c.RepresentAsInt32)
        .SetRepresentation(BsonType.Int32);
    cm.GetMemberMap(c =&amp;gt; c.RepresentAsString)
        .SetRepresentation(BsonType.String);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One case that deserves special mention is representing a string
externally as an &lt;code&gt;ObjectId&lt;/code&gt;. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class Employee {
    [BsonRepresentation(BsonType.ObjectId)]
    public string Id { get; set; }
    // other properties
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case the serializer will convert the &lt;code&gt;ObjectId&lt;/code&gt; to a string when
reading data from the database and will convert the string back to an
&lt;code&gt;ObjectId&lt;/code&gt; when writing data to the database (the string value must be a
valid &lt;code&gt;ObjectId&lt;/code&gt;). Typically this is done when you want to keep your
domain classes free of any dependencies on the C# driver, so you don&amp;rsquo;t
want to declare the &lt;code&gt;Id&lt;/code&gt; as an &lt;code&gt;ObjectId&lt;/code&gt;. String serves as a neutral
representation that is at the same time easily readable for debugging
purposes. To keep your domain classes free of dependencies on the C#
driver you also won&amp;rsquo;t want to use attributes, so you can accomplish the
same thing using initialization code instead of attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;Employee&amp;gt;(cm =&amp;gt; {
    cm.AutoMap();
    cm.IdMemberMap.SetRepresentation(BsonType.ObjectId);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;class-level-serialization-options&#34;&gt;Class Level Serialization Options&lt;/h2&gt;

&lt;p&gt;There are several serialization options that are related to the class
itself instead of to any particular field or property. You can set these
class level options either by decorating the class with serialization
related attributes or by writing initialization code. As usual, we will
show both ways in the examples.&lt;/p&gt;

&lt;h3 id=&#34;ignoring-extra-elements&#34;&gt;Ignoring Extra Elements&lt;/h3&gt;

&lt;p&gt;When a BSON document is deserialized the name of each element is used to
look up a matching field or property in the class map. Normally, if no
matching field or property is found, an exception will be thrown. If you
want to ignore extra elements during deserialization, use the following
attribute:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;[BsonIgnoreExtraElements]
public MyClass {
    // fields and properties
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or using initialization code instead of attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; {
    cm.AutoMap();
    cm.SetIgnoreExtraElements(true);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;supporting-extra-elements&#34;&gt;Supporting Extra Elements&lt;/h3&gt;

&lt;p&gt;You can design your class to be capable of handling any extra elements
that might be found in a BSON document during deserialization. To do so,
you must have a property of type &lt;code&gt;BsonDocument&lt;/code&gt; and you must identify
that property as the one that should hold any extra elements that are
found (or you can name the property &amp;ldquo;ExtraElements&amp;rdquo; so that the default
&lt;code&gt;ExtraElementsMemberConvention&lt;/code&gt; will find it automatically). For
example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public MyClass {
    // fields and properties
    [BsonExtraElements]
    public BsonDocument CatchAll { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or using initialization code instead of attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; {
    cm.AutoMap();
    cm.SetExtraElementsMember(cm.GetMemberMap(c =&amp;gt; c.CatchAll));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When a BSON document is deserialized any extra elements found will be
stored in the extra elements &lt;code&gt;BsonDocument&lt;/code&gt; property. When the class is
serialized the extra elements will be serialized also. One thing to note
though is that the serialized class will probably not have the elements
in exactly the same order as the original document. All extra elements
will be serialized together when the extra elements member is
serialized.&lt;/p&gt;

&lt;h3 id=&#34;polymorphic-classes-and-discriminators&#34;&gt;Polymorphic Classes and Discriminators&lt;/h3&gt;

&lt;p&gt;When you have a class hierarchy and will be serializing instances of
varying classes to the same collection you need a way to distinguish one
from another. The normal way to do so is to write some kind of special
value (called a &amp;ldquo;discriminator&amp;rdquo;) in the document along with the rest of
the elements that you can later look at to tell them apart. Since there
are potentially many ways you could discriminate between actual types,
the default serializer uses conventions for discriminators. The default
serializer provides two standard discriminators:
&lt;code&gt;ScalarDiscriminatorConvention&lt;/code&gt; and
&lt;code&gt;HierarchicalDiscriminatorConvention&lt;/code&gt;. The default is the
&lt;code&gt;HierarchicalDiscriminatorConvention&lt;/code&gt;, but it behaves just like the
&lt;code&gt;ScalarDiscriminatorConvention&lt;/code&gt; until certain options are set to trigger
its hierarchical behavior (more on this later).&lt;/p&gt;

&lt;p&gt;The default discriminator conventions both use an element named &lt;code&gt;_t&lt;/code&gt; to
store the discriminator value in the BSON document. This element will
normally be the second element in the BSON document (right after the
&lt;code&gt;_id&lt;/code&gt;). In the case of the &lt;code&gt;ScalarDiscriminatorConvention&lt;/code&gt; the value of
&lt;code&gt;_t&lt;/code&gt; will be a single string. In the case of the
&lt;code&gt;HierarchicalDiscriminatorConvention&lt;/code&gt; the value of &lt;code&gt;_t&lt;/code&gt; will be an array
of discriminator values, one for each level of the class inheritance
tree (again, more on this later).&lt;/p&gt;

&lt;p&gt;While you will normally be just fine with the default discriminator
convention, you might have to write a custom discriminator convention if
you must inter-operate with data written by another driver or object
mapper that uses a different convention for its discriminators.&lt;/p&gt;

&lt;h3 id=&#34;setting-the-discriminator-value&#34;&gt;Setting the Discriminator Value&lt;/h3&gt;

&lt;p&gt;The default value for the discriminator is the name of the class
(without the namespace part). You can specify a different value using
attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;[BsonDiscriminator(&amp;quot;myclass&amp;quot;)]
public MyClass {
    // fields and properties
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or using initialization code instead of attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;MyClass&amp;gt;(cm =&amp;gt; {
    cm.AutoMap();
    cm.SetDiscriminator(&amp;quot;myclass&amp;quot;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;specifying-known-types&#34;&gt;Specifying Known Types&lt;/h3&gt;

&lt;p&gt;When deserializing polymorphic classes it is important that the
serializer know about all the classes in the hierarchy before
deserialization begins. If you ever see an error message about an
&amp;ldquo;Unknown discriminator&amp;rdquo; it is because the deserializer can&amp;rsquo;t figure out
the class for that discriminator. If you are mapping your classes
programmatically simply make sure that all classes in the hierarchy have
been mapped before beginning deserialization. When using attributes and
automapping you will need to inform the serializer about known types
(i.e. subclasses) it should create class maps for. Here is an example of
how to do this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;[BsonKnownTypes(typeof(Cat), typeof(Dog)]
public class Animal {
}

[BsonKnownTypes(typeof(Lion), typeof(Tiger)]
public class Cat : Animal {
}

public class Dog : Animal {
}

public class Lion : Cat {
}

public class Tiger : Cat {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;BsonKnownTypes&lt;/code&gt; attribute lets the serializer know what subclasses
it might encounter during deserialization, so when &lt;code&gt;Animal&lt;/code&gt; is
automapped the serializer will also automap &lt;code&gt;Cat&lt;/code&gt; and &lt;code&gt;Dog&lt;/code&gt; (and
recursively, &lt;code&gt;Lion&lt;/code&gt; and &lt;code&gt;Tiger&lt;/code&gt; as well).&lt;/p&gt;

&lt;p&gt;Or using initialization code instead of attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;Animal&amp;gt;();
BsonClassMap.RegisterClassMap&amp;lt;Cat&amp;gt;();
BsonClassMap.RegisterClassMap&amp;lt;Dog&amp;gt;();
BsonClassMap.RegisterClassMap&amp;lt;Lion&amp;gt;();
BsonClassMap.RegisterClassMap&amp;lt;Tiger&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;scalar-and-hierarchical-discriminators&#34;&gt;Scalar and Hierarchical Discriminators&lt;/h3&gt;

&lt;p&gt;Normally a discriminator is simply the name of the class (although it
could be different if you are using a custom discriminator convention or
have explicitly specified a discriminator for a class). So a collection
containing a mix of different type of &lt;code&gt;Animal&lt;/code&gt; documents might look
like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;{ _t : &amp;quot;Animal&amp;quot;, ... }
{ _t : &amp;quot;Cat&amp;quot;, ... }
{ _t : &amp;quot;Dog&amp;quot;, ... }
{ _t : &amp;quot;Lion&amp;quot;, ... }
{ _t : &amp;quot;Tiger&amp;quot;, ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sometimes it can be helpful to record a hierarchy of discriminator
values, one for each level of the hierarchy. To do this, you must first
mark a base class as being the root of a hierarchy, and then the default
&lt;code&gt;HierarchicalDiscriminatorConvention&lt;/code&gt; will automatically record
discriminators as array values instead.&lt;/p&gt;

&lt;p&gt;To identify &lt;code&gt;Animal&lt;/code&gt; as the root of a hierarchy use the
&lt;code&gt;BsonDiscriminator&lt;/code&gt; attribute with the &lt;code&gt;RootClass&lt;/code&gt; named parameter:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;[BsonDiscriminator(RootClass = true)]
[BsonKnownTypes(typeof(Cat), typeof(Dog)]
public class Animal {
}

// the rest of the hierarchy as before
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or using initialization code instead of attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;Animal&amp;gt;(cm =&amp;gt; {
    cm.AutoMap();
    cm.SetIsRootClass(true);
});
BsonClassMap.RegisterClassMap&amp;lt;Cat&amp;gt;();
BsonClassMap.RegisterClassMap&amp;lt;Dog&amp;gt;();
BsonClassMap.RegisterClassMap&amp;lt;Lion&amp;gt;();
BsonClassMap.RegisterClassMap&amp;lt;Tiger&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that you have identified &lt;code&gt;Animal&lt;/code&gt; as a root class, the discriminator
values will look a little bit different:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;{ _t : &amp;quot;Animal&amp;quot;, ... }
{ _t : [&amp;quot;Animal&amp;quot;, &amp;quot;Cat&amp;quot;], ... }
{ _t : [&amp;quot;Animal&amp;quot;, &amp;quot;Dog&amp;quot;], ... }
{ _t : [&amp;quot;Animal&amp;quot;, &amp;quot;Cat&amp;quot;, &amp;quot;Lion&amp;quot;], ... }
{ _t : [&amp;quot;Animal&amp;quot;, &amp;quot;Cat&amp;quot;, &amp;quot;Tiger&amp;quot;], ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main reason you might choose to use hierarchical discriminators is
because it makes it possibly to query for all instances of any class in
the hierarchy. For example, to read all the &lt;code&gt;Cat&lt;/code&gt; documents we can
write:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var query = Query.EQ(&amp;quot;_t&amp;quot;, &amp;quot;Cat&amp;quot;);
var cursor = collection.FindAs&amp;lt;Animal&amp;gt;(query);
foreach (var cat in cursor) {
    // process cat
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works because of the way MongoDB handles queries against array
values.&lt;/p&gt;

&lt;h2 id=&#34;customizing-serialization&#34;&gt;Customizing Serialization&lt;/h2&gt;

&lt;p&gt;There are several ways you can customize serialization:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Implement &lt;code&gt;ISupportInitialize&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Make a class responsible for its own serialization.&lt;/li&gt;
&lt;li&gt;Supplementing the default serializer.&lt;/li&gt;
&lt;li&gt;Write a custom serializer.&lt;/li&gt;
&lt;li&gt;Write a custom attribute.&lt;/li&gt;
&lt;li&gt;Write a custom Id generator.&lt;/li&gt;
&lt;li&gt;Write a custom convention.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;implementing-isupportinitialize&#34;&gt;Implementing &lt;code&gt;ISupportInitialize&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;The driver respects an entity implementing &lt;code&gt;ISupportInitialize&lt;/code&gt; which
contains 2 methods, &lt;code&gt;BeginInit&lt;/code&gt; and &lt;code&gt;EndInit&lt;/code&gt;. These method are called
before deserialization begins and after it is complete. It is useful for
running operations before or after deserialization such as handling
schema changes are pre-calculating some expensive operations.&lt;/p&gt;

&lt;h3 id=&#34;supplementing-the-default-serializer-provider&#34;&gt;Supplementing the Default Serializer Provider&lt;/h3&gt;

&lt;p&gt;You can register your own serialization provider to supplement the
default serializer. Register it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;IBsonSerializationProvider myProvider;
BsonSerializer.RegisterSerializationProvider(myProvider);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should register your provider as early as possible. Your provider
will be called first before the default serializer. You can delegate
handling of any types your custom provider isn&amp;rsquo;t prepared to handle to
the default serializer by returning null from &lt;code&gt;GetSerializer&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;write-a-custom-serializer&#34;&gt;Write a Custom Serializer&lt;/h3&gt;

&lt;p&gt;A custom serializer can handle serialization of your classes without
requiring any changes to those classes. This is a big advantage when you
either don&amp;rsquo;t want to modify those classes or can&amp;rsquo;t (perhaps because you
don&amp;rsquo;t have control over them). You must register your custom serializer
so that the BSON Library knows of its existence and can call it when
appropriate.&lt;/p&gt;

&lt;p&gt;If you write a custom serializer you will have to become familiar with
the &lt;code&gt;BsonReader&lt;/code&gt; and &lt;code&gt;BsonWriter&lt;/code&gt; abstract classes, which are not
documented here, but are relatively straightforward to use. Look at the
existing serializers in the driver for examples of how &lt;code&gt;BsonReader&lt;/code&gt; and
&lt;code&gt;BsonWriter&lt;/code&gt; are used.&lt;/p&gt;

&lt;p&gt;To implement and register a custom serializer you would:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;// MyClass is the class for which you are writing a custom serializer
public MyClass {
}

// MyClassSerializer is the custom serializer for MyClass
public MyClassSerializer : IBsonSerializer {
    // implement Deserialize
    // implement GetDefaultSerializationOptions
    // implement Serialize
}

// register your custom serializer
BsonSerializer.RegisterSerializer(
    typeof(MyClass),
    new MyClassSerializer()
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also decorate the target class with a &lt;code&gt;BsonSerializer&lt;/code&gt; attribute
instead of using the &lt;code&gt;BsonSerializer.RegisterSerializer&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;[BsonSerializer(typeof(MyClassSerializer))]
public MyClass {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;IBsonSerializer&lt;/code&gt; interface is all that is necessary for
serialization. However, there are some extension interfaces that will
enable further use in other parts of the api such as saving a class or
LINQ.&lt;/p&gt;

&lt;p&gt;If your class is used as a root document, you will need to implement the
&lt;code&gt;IBsonIdProvider&lt;/code&gt; interface in order for &amp;ldquo;Saving&amp;rdquo; the document to
function. &lt;code&gt;MongoCollection.Save&lt;/code&gt; requires a document identity in order
to know if it should generate an insert or update statement. Below is
the extension to the above &lt;code&gt;MyClassSerializer&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public MyClassSerializer : IBsonSerializer, IBsonIdProvider {
    // ...

    // implement GetDocumentId
    // implement SetDocumentId
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to enable LINQ to properly construct type-safe queries using a
custom serializer, it needs access to member information or array
information. If your custom serializer is for a class, as
&lt;code&gt;MyClassSerializer&lt;/code&gt; is above, then you should implement
&lt;code&gt;IBsonDocumentSerializer&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public MyClassSerializer : IBsonSerializer, IBsonDocumentSerializer {
    // ...

    // implement GetMemberSerializationInfo
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If, however, your class is a collection that should be serialized as an
array, it should implement &lt;code&gt;IBsonArraySerializer&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public MyClassSerializer : IBsonSerializer, IBsonArraySerializer {
    // ...

    // implement GetItemSerializationInfo
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To debug a custom serializer you can either Insert a document containing
a value serialized by your custom serializer into some collection and
then use the mongo shell to examine what the resulting document looks
like. Alternatively you can use the &lt;code&gt;ToJson&lt;/code&gt; method to see the result of
the serializer without having to Insert anything into a collection as
follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;// assume a custom serializer has been registered for class C
var c = new C();
var json = c.ToJson();
// inspect the json string variable to see how c was serialized
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;write-a-custom-attribute&#34;&gt;Write a Custom Attribute&lt;/h3&gt;

&lt;p&gt;The auto mapping ability of BSON library utilizes attributes that
implement &lt;code&gt;IBsonClassMapAttribute&lt;/code&gt;, &lt;code&gt;IBsonMemberMapAttribute&lt;/code&gt;, or
&lt;code&gt;IBsonCreatorMapAttribute&lt;/code&gt; for class level attributes, member level
attributes, or creator level attributes respectively. Each of these
interfaces has a single method called Apply that is passed a
&lt;code&gt;BsonClassMap&lt;/code&gt;, a &lt;code&gt;BsonMemberMap&lt;/code&gt;, or a &lt;code&gt;BsonCreatorMap&lt;/code&gt; which it can
modify using public properties and methods. One example of this would be
to create an attribute called &lt;code&gt;BsonEncryptionAttribute&lt;/code&gt; that is used to
encrypt a string before sending it to the database and decrypt it when
reading it back out.&lt;/p&gt;

&lt;p&gt;View the existing attributes for examples of how these interfaces
function.&lt;/p&gt;

&lt;h3 id=&#34;write-a-custom-id-generator&#34;&gt;Write a custom Id generator&lt;/h3&gt;

&lt;p&gt;You can write your own &lt;code&gt;IdGenerator&lt;/code&gt;. For example, suppose you wanted to
generate integer Employee Ids:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class EmployeeIdGenerator : IIdGenerator {
    // implement GenerateId
    // implement IsEmpty
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can specify that this generator be used for Employee Ids using
attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class Employee {
    [BsonId(IdGenerator = typeof(EmployeeIdGenerator)]
    public int Id { get; set; }
    // other fields or properties
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or using initialization code instead of attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;BsonClassMap.RegisterClassMap&amp;lt;Employee &amp;gt;(cm =&amp;gt; {
    cm.AutoMap();
    cm.IdMember.SetIdGenerator(new EmployeeIdGenerator());
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, you can get by without an Id generator at all by just
assigning a value to the &lt;code&gt;Id&lt;/code&gt; property before calling &lt;code&gt;Insert&lt;/code&gt; or
&lt;code&gt;Save&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;write-a-custom-convention&#34;&gt;Write a Custom Convention&lt;/h3&gt;

&lt;p&gt;Earlier in this tutorial we discussed replacing one or more of the
default conventions. You can either replace them with one of the
provided alternatives or you can write your own convention. Writing your
own convention varies slightly from convention to convention.&lt;/p&gt;

&lt;p&gt;As an example, we will write a custom convention to name all the
elements the corresponding lower-case version of the member name. We can
implement this convention as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class LowerCaseElementNameConvention : IMemberMapConvention {
    public void Apply(BsonMemberMap memberMap) {
        memberMap.SetElementName(memberMap.MemberName.ToLower());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you are doing one-off conventions like this, it might be easier to
create them with a simple lambda expresion instead. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;var pack = new ConventionPack();
pack.AddMemberMapConvention(
    &amp;quot;LowerCaseElementName&amp;quot;,
    m =&amp;gt; m.SetElementName(m.MemberName.ToLower()));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the best examples of writing custom conventions, it is good to
consult the source for the pre-packaged conventions.&lt;/p&gt;

&lt;h2 id=&#34;handling-schema-changes&#34;&gt;Handling Schema Changes&lt;/h2&gt;

&lt;p&gt;Just because MongoDB is schema-less does not mean that your code can
handle a schema-less document. Most likely, if you are using a
statically typed language like C# or VB.NET, then your code is
not-flexible and needs to be mapped to a known schema.&lt;/p&gt;

&lt;p&gt;There are a number of different ways that a schema can change from one
version of your application to the next.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A new member is added.&lt;/li&gt;
&lt;li&gt;A member is deleted.&lt;/li&gt;
&lt;li&gt;A member is renamed.&lt;/li&gt;
&lt;li&gt;The type of a member is changed.&lt;/li&gt;
&lt;li&gt;The representation of a member is changed.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;How you handle these is up to you. There primary two different
strategies.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Write an upgrade script.&lt;/li&gt;
&lt;li&gt;Incrementally update your documents as they are used.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The easiest and most bullet-proof of the strategies is to write an
upgrade script. There is effectively no difference to this method
between a relational database (SQL Server, Oracle) and MongoDB. Identify
the documents that need to be changed and update them.&lt;/p&gt;

&lt;p&gt;Alternatively, and not supportable in most relational databases, is the
incremental upgrade. The idea is that your documents get updated as they
are used. Documents that are never used never get updated. Because of
this, there are some definite pitfalls you will need to be aware of.&lt;/p&gt;

&lt;p&gt;First, queries against a schema where half the documents are version 1
and half the documents are version 2 could go awry. For instance, if you
rename an element, then your query will need to test both the old
element name and the new element name to get all the results.&lt;/p&gt;

&lt;p&gt;Second, any incremental upgrade code must stay in the code-base until
all the documents have been upgraded. For instance, if there have been 3
versions of a document, [1, 2, and 3] and we remove the upgrade code
from version 1 to version 2, any documents that still exist as version 1
are un-upgradeable.&lt;/p&gt;

&lt;p&gt;So, with that being said, let&amp;rsquo;s talk about handling the schema change
variations.&lt;/p&gt;

&lt;h3 id=&#34;a-member-has-been-added&#34;&gt;A Member Has Been Added&lt;/h3&gt;

&lt;p&gt;When a new member is added to an entity, there is nothing that needs to
be done other than restarting the application if you are using the auto
mapping features. If not, then you will manually need to map the member
in the same way all the other members are getting mapped.&lt;/p&gt;

&lt;p&gt;Existing documents will not have this element and it will show up in
your class with its default value. You can, of course, specify a default
value.&lt;/p&gt;

&lt;h3 id=&#34;a-member-has-been-removed&#34;&gt;A Member Has Been Removed&lt;/h3&gt;

&lt;p&gt;When a member has been removed from am entity, it will continue to exist
in the documents. The serializer will throw an exception when this
element is seen because it doesn&amp;rsquo;t know what to do with it. The 2
previously discussed items that can be used to combat this are the
&lt;code&gt;BsonIgnoreExtraElements&lt;/code&gt; class-level attribute and the &lt;code&gt;ExtraElements&lt;/code&gt;
members.&lt;/p&gt;

&lt;h3 id=&#34;a-member-is-renamed&#34;&gt;A Member Is Renamed&lt;/h3&gt;

&lt;p&gt;When a member has been renamed, it will exist in old documents with the
old name and in new documents with the new name. The way to handle
incremental upgrades for this rename would be to implement an
&lt;code&gt;ExtraElements&lt;/code&gt; member in conjunction with &lt;code&gt;ISupportInitialize&lt;/code&gt;. For
example, let&amp;rsquo;s say that a class used to have a &lt;code&gt;Name&lt;/code&gt; property which has
now been split into a &lt;code&gt;FirstName&lt;/code&gt; and a &lt;code&gt;LastName&lt;/code&gt; property.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sourceCode csharp&#34;&gt;public class MyClass : ISupportInitialize {
    public string FirstName { get; set; }
    public string LastName { get; set; }

    [BsonExtraElements]
    public IDictionary&amp;lt;string, object&amp;gt; ExtraElements { get; set; }

    void ISupportInitialize.BeginInit() {
        // nothing to do at begin
    }

    void ISupportInitialize.EndInit() {
        object nameValue;
        if(!ExtraElements.TryGetValue(&amp;quot;Name&amp;quot;, out nameValue)) {
            return;
        }

        var name = (string)nameValue;

        // remove the Name element so that it doesn&#39;t get persisted back to the database
        ExtraElements.Remove(&amp;quot;Name&amp;quot;);

        // assuming all names are &amp;quot;First Last&amp;quot;
        var nameParts = name.Split(&#39; &#39;);

        FirstName = nameParts[0];
        LastName = nameParts[1];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;the-type-of-a-member-is-changed&#34;&gt;The Type of a Member Is Changed&lt;/h3&gt;

&lt;p&gt;If the .NET type is compatible with the old type (an integer is changed
to a double), then everything will continue to work. Otherwise, a custom
serializer or a migration script will be required.&lt;/p&gt;

&lt;h3 id=&#34;the-representation-of-a-member-is-changed&#34;&gt;The Representation of a Member Is Changed&lt;/h3&gt;

&lt;p&gt;If the representation of a member is changed and the representations are
compatible, then everything will continue to work. Otherwise, a custom
serializer or a migration script will be required.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>index</title>
      <link>/mongo-csharp-driver/1.11/</link>
      <pubDate>Tue, 17 Mar 2015 15:36:56 +0000</pubDate>
      
      <guid>/mongo-csharp-driver/1.11/</guid>
      <description>

&lt;h2 id=&#34;welcome-to-the-legacy-net-mongodb-driver-documentation&#34;&gt;Welcome to the Legacy .NET MongoDB Driver Documentation&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;/mongo-csharp-driver/1.11/mongo-csharp-driver/1.11/getting_started/&#34;&gt;Getting Started&lt;/a&gt; guide contains information about system requirements, installation, and a simple tutorial to get up and running quickly.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;/mongo-csharp-driver/1.11/mongo-csharp-driver/1.11/driver/&#34;&gt;Driver Tutorial&lt;/a&gt; contains information on using the driver.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;/mongo-csharp-driver/1.11/mongo-csharp-driver/1.11/serialization/&#34;&gt;Serialization Tutorial&lt;/a&gt; contains information about serialization and mapping of .NET class to and from BSON.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;/mongo-csharp-driver/1.11/mongo-csharp-driver/1.11/linq/&#34;&gt;LINQ Tutorial&lt;/a&gt; contains information about supported LINQ operations.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>